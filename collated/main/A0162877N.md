# A0162877N
###### \java\seedu\address\commons\events\ui\CheckBoxSelectionChangedEvent.java
``` java
/**
 * This class handles the check box selection change event
 */
public class CheckBoxSelectionChangedEvent extends BaseEvent {
    private final int taskIndex;
    private final boolean status;

    public CheckBoxSelectionChangedEvent(int taskIndex, boolean status) {
        this.taskIndex = taskIndex;
        this.status = status;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public int getTaskIndex() {
        return taskIndex;
    }

    public boolean getTaskStatus() {
        return status;
    }
}
```
###### \java\seedu\address\commons\events\ui\LeftPanelSelectionChangedEvent.java
``` java
/**
* This class handles the left panel selection change event
*/
public class LeftPanelSelectionChangedEvent extends BaseEvent {

    private final String newSelection;

    public LeftPanelSelectionChangedEvent(String newSelection) {
        this.newSelection = newSelection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public String getNewSelection() {
        return newSelection;
    }

}
```
###### \java\seedu\address\commons\events\ui\LeftPanelTodaySelectionChangedEvent.java
``` java
/**
* This class handles the left panel today selection event
*/
public class LeftPanelTodaySelectionChangedEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\address\commons\events\ui\ShowAllSelectionChangedEvent.java
``` java
/**
* This class handles the show all selection change event
*/
public class ShowAllSelectionChangedEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\address\commons\exceptions\IllegalDateTimeValueException.java
``` java
/**
 * Signals that the given date cannot be parse to DateTimeParserManager.
 */
public class IllegalDateTimeValueException extends Exception {

    public static final String MESSAGE_DEADLINE_ERROR_PARSING = "Deadline provided is in the wrong format!";

    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public IllegalDateTimeValueException() {
        super(MESSAGE_DEADLINE_ERROR_PARSING);
    }
}
```
###### \java\seedu\address\commons\exceptions\InvalidUndoCommandException.java
``` java
/**
 * Signals that some given data does not fulfill some constraints.
 */
public class InvalidUndoCommandException extends Exception {
    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public InvalidUndoCommandException(String message) {
        super(message);
    }
}
```
###### \java\seedu\address\commons\util\DateTimeUtil.java
``` java
public class DateTimeUtil {

    public static final String DEFAULT_STARTTIME = "00:00:00";
    public static final String DEFAULT_ENDTIME = "23:59:59";
    public static final int DATE_INDEX = 0;
    public static final String DATE_DELIMITER = ",";

    @SuppressWarnings("deprecation")
    public static Date getEndDate() {
        Date endTime = new Date(2222, 1, 1);
        endTime.setHours(23);
        endTime.setMinutes(59);
        endTime.setSeconds(59);
        return endTime;
    }

    @SuppressWarnings("deprecation")
    public static Date getStartDate() {
        Date startDate = new Date();
        startDate.setHours(0);
        startDate.setMinutes(0);
        startDate.setSeconds(0);
        return startDate;
    }
}
```
###### \java\seedu\address\logic\commands\BookCommand.java
``` java
/**
 * Adds a booking to the Task Manager
 */
public class BookCommand extends Command {

    public static final String COMMAND_WORD = "book";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Books time slots for a task. "
            + "Parameters: TITLE [#LABEL] on DATE STARTTIME to ENDTIME, DATE STARTTIME to ENDTIME...\n"
            + "Example: " + COMMAND_WORD
            + " Meet John Doe #friends #owesMoney on 31 Mar 2017 2pm to 5pm,"
            + " 01 Oct 2017 2pm to 5pm, 30 Oct 2017 1pm to 2pm";
    public static final String MESSAGE_SUCCESS = "New booking added: %1$s";
    public static final String MESSAGE_DUPLICATE_BOOKING = "This booking already exists in the task manager";

    private final Task toAdd;

    public BookCommand(String title, Set<String> labels, String...dates)
            throws IllegalValueException, CommandException {
        final Set<Label> labelSet = new HashSet<>();
        final Set<Booking> bookingSet = new HashSet<>();
        for (String labelName : labels) {
            labelSet.add(new Label(labelName));
        }

        for (String bookingSlot : dates) {
            bookingSet.add(new Booking(bookingSlot));
        }

        this.toAdd = new Task(
                new Title(title),
                Optional.empty(),
                Optional.empty(),
                false,
                new UniqueLabelList(labelSet),
                new UniqueBookingList(bookingSet),
                false,
                Optional.empty()
        );
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            saveCurrentState();
            model.addTask(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_BOOKING);
        }
    }

    /**
     * Save the data in task manager if command is mutating the data
     */
    public void saveCurrentState() {
        if (isMutating()) {
            try {
                UndoManager.getInstance().addStorageHistory(model.getTaskManager().getImmutableTaskList(),
                        model.getTaskManager().getImmutableLabelList());
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public boolean isMutating() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\ConfirmCommand.java
``` java
/**
 * This class handles the confirmation of a booking time slot of a booking
 */
public class ConfirmCommand extends Command {

    public static final String COMMAND_WORD = "confirm";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Confirms the bookings of the task identified "
            + "by the index number used in the last task listing. "
            + "Other booking slots will be removed.\n"
            + "Parameters: INDEX (index of the task in the current task list and must be a positive integer)\n"
            + "Parameters: INDEX (index of the time slot to confirm and must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1 1";
    public static final String MESSAGE_NO_SUCH_BOOKING = "Index provided is invalid.\n" + MESSAGE_USAGE;
    public static final String MESSAGE_TASK_NO_BOOKING = "This task does not have bookings to confirm.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Confirmed Task: %1$s";
    private static final Logger logger = LogsCenter.getLogger(EventsCenter.class);

    private final int filteredTaskListIndex;
    private final int bookingSlotIndex;

    public ConfirmCommand(int filteredTaskListIndex, int bookingSlotIndex) {
        assert filteredTaskListIndex > 0;
        assert bookingSlotIndex > 0;
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        this.bookingSlotIndex = bookingSlotIndex - 1;
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASKS_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = null;
        try {
            taskToEdit = lastShownList.get(filteredTaskListIndex);
            Task editedTask = confirmTaskBooking(taskToEdit, bookingSlotIndex);
            saveCurrentState();
            model.updateTask(filteredTaskListIndex, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (IllegalValueException e) {
            e.printStackTrace();
        } catch (IllegalDateTimeValueException e) {
            e.printStackTrace();
        }
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     * @throws IllegalDateTimeValueException
     * @throws IllegalValueException
     * @throws CommandException
     */
    private static Task confirmTaskBooking(ReadOnlyTask taskToEdit, int bookingSlotIndex)
            throws IllegalValueException, IllegalDateTimeValueException, CommandException {
        assert taskToEdit != null;
        if (!taskToEdit.getBookings().isEmpty()) {
            ObservableList<Booking> bookingList = taskToEdit.getBookings().asObservableList();
            logger.info("Booking List size: " + bookingList.size());
            if (bookingSlotIndex >= bookingList.size()) {
                throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
            }
            Booking booking = bookingList.get(bookingSlotIndex);
            Optional<Deadline> updatedStartTime = Optional.ofNullable(
                    new Deadline(booking.getBookingStartDate().toString()));
            Optional<Deadline> updatedEndTime = Optional.ofNullable(
                    new Deadline(booking.getBookingEndDate().toString()));
            return new Task(taskToEdit.getTitle(),
                    updatedStartTime,
                    updatedEndTime,
                    taskToEdit.isCompleted(),
                    taskToEdit.getLabels(),
                    new UniqueBookingList(),
                    false,
                    Optional.empty());
        } else {
            throw new CommandException(MESSAGE_TASK_NO_BOOKING);
        }
    }

    /**
     * Save the data in task manager if command is mutating the data
     */
    public void saveCurrentState() {
        if (isMutating()) {
            try {
                UndoManager.getInstance().addStorageHistory(model.getTaskManager().getImmutableTaskList(),
                        model.getTaskManager().getImmutableLabelList());
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public boolean isMutating() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\EditBookingCommand.java
``` java
/**
 * Add, change or remove booking time slot in the Task Manager
 */
public class EditBookingCommand extends Command {

    public static final String COMMAND_WORD = "editbooking";
    public static final String MESSAGE_DUPLICATE_BOOKING = "This booking already exists in the task manager";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the booking of the task identified "
            + "by the index number used in the last task listing. "
            + "Parameters: INDEX (index of the task in the current task list and must be a positive integer)\n"
            + "Parameters: [add DATE, MORE DATES] | [remove BOOKING_INDEX] | [change BOOKING_INDEX DATE]\n"
            + "Example: " + COMMAND_WORD + " 1 add tuesday 2pm to 5pm\n" + "Example: " + COMMAND_WORD + " 1 remove 1\n"
            + "Example: " + COMMAND_WORD + " 1 change 1 tuesday 1pm to 4pm\n";
    public static final String MESSAGE_NO_SUCH_BOOKING = "Index provided is invalid.\n" + MESSAGE_USAGE;
    public static final String MESSAGE_TASK_NO_BOOKING = "This task does not have bookings to update.";
    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final int BOOKING_INDEX = 0;
    public static final int VALID_INDEX = 0;

    private final int filteredTaskListIndex;
    private final int bookingSlotIndex;
    private final Set<Booking> bookingSet;

    public EditBookingCommand(int filteredTaskListIndex, int bookingSlotIndex) {
        assert filteredTaskListIndex > VALID_INDEX;
        assert bookingSlotIndex > VALID_INDEX;
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        this.bookingSlotIndex = bookingSlotIndex - 1;
        this.bookingSet = new HashSet<>();
    }

    public EditBookingCommand(int filteredTaskListIndex, String... dates) throws CommandException {
        assert filteredTaskListIndex > VALID_INDEX;
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        bookingSlotIndex = -1;
        bookingSet = new HashSet<>();
        for (String bookingSlot : dates) {
            bookingSet.add(new Booking(bookingSlot));
        }
    }

    public EditBookingCommand(int filteredTaskListIndex, int bookingSlotIndex, String date)
            throws CommandException {
        assert filteredTaskListIndex > VALID_INDEX;
        assert bookingSlotIndex > VALID_INDEX;
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        this.bookingSlotIndex = bookingSlotIndex - 1;
        bookingSet = new HashSet<>();
        bookingSet.add(new Booking(date));
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        try {
            boolean bookingSuccess = false;
            if (bookingSet.isEmpty() && bookingSlotIndex >= VALID_INDEX) {
                bookingSuccess = removeBookingsInTasks(lastShownList);
            } else if (!bookingSet.isEmpty() && bookingSlotIndex >= VALID_INDEX) {
                bookingSuccess = changeBookingsInTasks(lastShownList);
            } else if (!bookingSet.isEmpty()) {
                bookingSuccess = addBookingsInTasks(lastShownList);
            } else {
                throw new CommandException(MESSAGE_TASK_NO_BOOKING);
            }

            if (!bookingSuccess) {
                throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
            }

            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, filteredTaskListIndex + 1));
        } catch (DuplicateBookingException e) {
            throw new CommandException(e.getMessage());
        }
    }

    /**
     * Removes a specific booking time slot in the booking
     *
     * @param lastShownList
     * @return true if the specified booking exists
     * @throws DuplicateBookingException
     */
    private boolean removeBookingsInTasks(List<ReadOnlyTask> lastShownList)
            throws CommandException, DuplicateBookingException {
        boolean bookingExist = false;
        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASKS_DISPLAYED_INDEX);
        } else {
            Task task = new Task(lastShownList.get(filteredTaskListIndex));
            UniqueBookingList bookings = task.getBookings();
            if (!bookings.isEmpty()) {
                List<Booking> bookingList = bookings.toList();
                if (bookingSlotIndex >= bookingList.size()) {
                    throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
                }
                bookingList.remove(bookingSlotIndex);
                Collections.sort(bookingList);
                task.setBookings(new UniqueBookingList(bookingList));
                bookingExist = true;
                try {
                    saveCurrentState();
                    model.updateTask(filteredTaskListIndex, task);
                } catch (DuplicateTaskException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_BOOKING);
                }
            } else {
                throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
            }
        }
        return bookingExist;
    }

    /**
     * Adds time slots in booking
     *
     * @param lastShownList
     * @return true if the specified booking exists
     * @throws DuplicateBookingException
     */
    private boolean addBookingsInTasks(List<ReadOnlyTask> lastShownList)
            throws CommandException, DuplicateBookingException {
        boolean bookingSuccess = false;
        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASKS_DISPLAYED_INDEX);
        } else {
            Task task = new Task(lastShownList.get(filteredTaskListIndex));
            UniqueBookingList bookings = task.getBookings();
            if (!bookings.isEmpty()) {
                Set<Booking> taskBookingSet = bookings.toSet();
                List<Booking> bookingList = new ArrayList<Booking>(bookingSet);
                for (Booking booking : bookingList) {
                    taskBookingSet.add(booking);
                }
                task.setBookings(new UniqueBookingList(taskBookingSet));
                bookingSuccess = true;
                try {
                    saveCurrentState();
                    model.updateTask(filteredTaskListIndex, task);
                } catch (DuplicateTaskException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_BOOKING);
                }
            } else {
                throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
            }
        }
        return bookingSuccess;
    }

    /**
     * Replaces a specific booking time slot in bookings
     *
     * @param allTaskList
     * @return true if the specified booking exists
     * @throws DuplicateBookingException
     */
    private boolean changeBookingsInTasks(List<ReadOnlyTask> lastShownList)
            throws CommandException, DuplicateBookingException {
        boolean bookingExist = false;
        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASKS_DISPLAYED_INDEX);
        } else {
            Task task = new Task(lastShownList.get(filteredTaskListIndex));
            UniqueBookingList bookings = task.getBookings();
            if (!bookings.isEmpty()) {
                List<Booking> bookingList = bookings.toList();
                if (bookingSlotIndex >= bookingList.size() || bookingSlotIndex < VALID_INDEX) {
                    throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
                }
                if (!bookings.contains(new ArrayList<Booking>(bookingSet).get(BOOKING_INDEX))) {
                    bookingList.remove(bookingSlotIndex);
                    bookingList.add(new ArrayList<Booking>(bookingSet).get(BOOKING_INDEX));
                }
                Collections.sort(bookingList);
                task.setBookings(new UniqueBookingList(bookingList));
                bookingExist = true;
                try {
                    saveCurrentState();
                    model.updateTask(filteredTaskListIndex, task);
                } catch (DuplicateTaskException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_BOOKING);
                }
            } else {
                throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
            }
        }
        return bookingExist;
    }

    /**
     * Save the data in task manager if command is mutating the data
     */
    public void saveCurrentState() {
        if (isMutating()) {
            try {
                UndoManager.getInstance().addStorageHistory(model.getTaskManager().getImmutableTaskList(),
                        model.getTaskManager().getImmutableLabelList());
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public boolean isMutating() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\FindCommand.java
``` java
/**
 * Finds and lists all tasks in task manager whose name contains any of the
 * argument keywords. Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose names contain any of "
            + "the specified keywords (case-insensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]... | [(by DEADLINE) | (from STARTDATE to ENDDATE)]\n"
            + "Example: " + COMMAND_WORD + " meet alice";

    private final Set<String> keywords;
    private final String startDate;
    private final String endDate;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
        this.startDate = null;
        this.endDate = null;
    }

    public FindCommand(String endDate) throws IllegalDateTimeValueException {
        this.startDate = "";
        this.endDate = endDate;
        this.keywords = null;
    }

    public FindCommand(String startDate, String endDate) throws IllegalDateTimeValueException {
        this.startDate = startDate;
        this.endDate = endDate;
        this.keywords = null;
    }

    /**
     * Returns true if a given string is a valid date.
     */
    public boolean isParsableDate(String dateTime) {
        dtParser.parse(dateTime);
        return !dtParser.parse(dateTime).isEmpty();
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            executeFindCommandLogic();
            return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
        } catch (IllegalDateTimeValueException e) {
            throw new CommandException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }
    }

    public void executeFindCommandLogic() throws IllegalDateTimeValueException {
        if (keywords == null) {
            if ("".equals(startDate) && isParsableDate(endDate)) { // by prefix is used by user
                executeFindWithEndDate();
            } else if (isParsableDate(startDate) && isParsableDate(endDate)) { // from and to prefix is used by user
                executeFindWithDateRange();
            } else {
                throw new IllegalDateTimeValueException();
            }
        } else { // no dates specified by user only search for keywords
            model.updateFilteredTaskList(keywords);
        }
    }

    public void executeFindWithDateRange() {
        Date start = null;
        Date end = null;
        if (dtParser.parse(endDate).get(DateTimeUtil.DATE_INDEX).isTimeInferred()) {
            end = dtParser.parse(endDate + " " + DateTimeUtil.DEFAULT_ENDTIME)
                    .get(DateTimeUtil.DATE_INDEX)
                    .getDates()
                    .get(DateTimeUtil.DATE_INDEX);
        } else {
            end = dtParser.parse(endDate).get(DateTimeUtil.DATE_INDEX)
                    .getDates()
                    .get(DateTimeUtil.DATE_INDEX);
        }

        if (dtParser.parse(startDate).get(DateTimeUtil.DATE_INDEX).isTimeInferred()) {
            start = dtParser.parse(startDate + " " + DateTimeUtil.DEFAULT_STARTTIME)
                    .get(DateTimeUtil.DATE_INDEX)
                    .getDates()
                    .get(DateTimeUtil.DATE_INDEX);
        } else {
            start = dtParser.parse(startDate).get(DateTimeUtil.DATE_INDEX)
                    .getDates()
                    .get(DateTimeUtil.DATE_INDEX);
        }

        executeFindCommand(start, end);
    }

    public void executeFindWithEndDate() {
        Date start = null;
        Date end = null;
        if (dtParser.parse(endDate).get(DateTimeUtil.DATE_INDEX).isTimeInferred()) {
            end = dtParser.parse(endDate + " " + DateTimeUtil.DEFAULT_ENDTIME)
                    .get(DateTimeUtil.DATE_INDEX)
                    .getDates()
                    .get(DateTimeUtil.DATE_INDEX);
        } else {
            end = dtParser.parse(endDate).get(DateTimeUtil.DATE_INDEX)
                    .getDates()
                    .get(DateTimeUtil.DATE_INDEX);
        }

        start = dtParser.parse("today " + DateTimeUtil.DEFAULT_STARTTIME)
                .get(DateTimeUtil.DATE_INDEX)
                .getDates()
                .get(DateTimeUtil.DATE_INDEX);

        executeFindCommand(start, end);
    }

    /**
     * Compare the start and end date and execute the filter method
     */
    private void executeFindCommand(Date start, Date end) {
        if (end.before(start)) {
            model.updateFilteredTaskList(end, start);
        } else {
            model.updateFilteredTaskList(start, end);
        }
    }

    @Override
    public boolean isMutating() {
        return false;
    }

}
```
###### \java\seedu\address\logic\commands\ListCommand.java
``` java
/**
 * Lists all tasks in the task manager to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    public static final String MESSAGE_SUCCESS = "Listed all tasks";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " [by DEADLINE] | [from STARTDATE to ENDDATE]"
            + " | [completed | incomplete]";
    private final String endDate;
    private final String startDate;
    private final Boolean isCompleted;

    public ListCommand() {
        isCompleted = null;
        endDate = "";
        startDate = "";
    }

```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
/**
 * Undo the most recent mutating command from the task manager,
 * returning the data to the previous state
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String MESSAGE_SUCCESS = "Undo-ed previous command successfully!\n"
            + "To Redo past command, hit the up arrow key.";
    public static final String MESSAGE_USAGE = COMMAND_WORD;
    public static final String MESSAGE_UNSUCCESSFUL_UNDO = "No previous command to undo.";

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            if (!UndoManager.getInstance().isEmpty()) {
                UndoPair<ObservableList<ReadOnlyTask>, ObservableList<Label>> pair =
                        UndoManager.getInstance().getUndoData();
                model.undoPrevious(pair.getLeft(), pair.getRight());
                return new CommandResult(String.format(MESSAGE_SUCCESS));
            } else {
                throw new InvalidUndoCommandException(MESSAGE_UNSUCCESSFUL_UNDO);
            }
        } catch (InvalidUndoCommandException e) {
            throw new CommandException(e.getMessage());
        }
    }

    @Override
    public boolean isMutating() {
        return true;
    }

}
```
###### \java\seedu\address\logic\dateparser\DateTimeManager.java
``` java
/**
* Parses date input arguments to Natty
*/
public class DateTimeManager implements DateTimeParser {
    private TimeZone defaultTimeZone;
    private static final Logger logger = LoggerFactory.getLogger(Parser.class);

    /**
     * Tokens that should be removed from the end any list of tokens before
     * parsing. These are valid tokens, but could never add any meaningful
     * parsing information when located at the end of a token stream.
     */
    private static final Set<Integer> IGNORED_TRAILING_TOKENS = new HashSet<Integer>(
            Arrays.asList(new Integer[] { DateLexer.DOT, DateLexer.COLON, DateLexer.COMMA, DateLexer.DASH,
                DateLexer.SLASH, DateLexer.DOT, DateLexer.PLUS, DateLexer.SINGLE_QUOTE }));

    /**
     * Creates a new parser with default time zone
     */
    public DateTimeManager() {
        defaultTimeZone = TimeZone.getDefault();
    }

    /**
     * Parses the given input value for one or more groups of date alternatives
     *
     * @param value the value to parse
     * @return List of Date group containing the dates after parsing to natty
     */
    public List<DateGroup> parse(String value) {
        return parse(value, new Date());
    }

    /**
     * Parses the given input value for one or more groups of date alternatives
     * with relative dates resolved according to referenceDate
     */
    public List<DateGroup> parse(String value, Date referenceDate) {
        // lex the input value to obtain our global token stream
        ANTLRInputStream input = null;

        try {
            input = new ANTLRNoCaseInputStream(new ByteArrayInputStream(value.getBytes()));

        } catch (IOException e) {
            logger.error("could not lex input", e);
        }
        DateLexer lexer = new DateLexer(input);

        // collect all sub-token streams that may include date information
        List<TokenStream> streams = collectTokenStreams(new CommonTokenStream(lexer));

        // and parse each of them
        List<DateGroup> groups = new ArrayList<DateGroup>();
        TokenStream lastStream = null;
        for (TokenStream stream : streams) {
            lastStream = stream;
            getDateGroup(value, referenceDate, streams, groups, lastStream, stream);
        }
        return groups;
    }

    /**
     * Parses the string value input from user to natty and add to the date group list
     */
    private void getDateGroup(String value, Date referenceDate, List<TokenStream> streams, List<DateGroup> groups,
            TokenStream lastStream, TokenStream stream) {
        List<Token> tokens = ((NattyTokenSource) stream.getTokenSource()).getTokens();
        DateGroup group = singleParse(stream, value, referenceDate);

        while ((group == null || group.getDates().size() == 0) && tokens.size() > 0) {
            if (group == null || group.getDates().size() == 0) {
                List<Token> endRemovedTokens = new ArrayList<Token>(tokens);
                while ((group == null || group.getDates().isEmpty()) && !endRemovedTokens.isEmpty()) {
                    endRemovedTokens = endRemovedTokens.subList(0, endRemovedTokens.size() - 1);
                    TokenStream newStream = new CommonTokenStream(new NattyTokenSource(endRemovedTokens));
                    group = singleParse(newStream, value, referenceDate);
                    lastStream = newStream;
                }

                while ((group == null || group.getDates().isEmpty()) && tokens.size() >= 1) {
                    tokens = tokens.subList(1, tokens.size());
                    Iterator<Token> iter = tokens.iterator();
                    removeInvalidToken(iter);
                    TokenStream newStream = new CommonTokenStream(new NattyTokenSource(tokens));
                    group = singleParse(newStream, value, referenceDate);
                    lastStream = newStream;
                }
            }
        }

        // If a group with at least one date was found, add it to the list,
        // but not if multiple streams were found and the group contains
        // only numeric time information.
        // For example: A full text string of '1' should parse to 1 o'clock,
        // but 'I need 1 hard drive'
        // should result in no groups found.
        if (group != null && !group.getDates().isEmpty()
                && (streams.size() == 1 || !group.isDateInferred() || !isAllNumeric(lastStream))) {

            // Additionally, only accept this group if the associated
            // text does not have an
            // alphabetic character to the immediate left or right, which
            // would indicate a portion
            // of a word was tokenized. For example, 'nightingale' will
            // result in a 'NIGHT' token,
            // but there's clearly no datetime information there.
            group.setFullText(value);
            String prefix = group.getPrefix(1);
            String suffix = group.getSuffix(1);
            if ((prefix.isEmpty() || !Character.isLetter(prefix.charAt(0)))
                    && (suffix.isEmpty() || !Character.isLetter(suffix.charAt(0)))) {
                groups.add(group);
            }
        }
    }

    /**
     * Check if the token if valid, if not remove the toekn
     */
    private void removeInvalidToken(Iterator<Token> iterator) {
        while (iterator.hasNext()) {
            Token token = iterator.next();
            if (!DateParser.FOLLOW_empty_in_parse186.member(token.getType())) {
                iterator.remove();
            } else {
                break;
            }
        }
    }

    /**
     * Determines if a token stream contains only numeric tokens
     * @param TokenStream object
     * @return true if all tokens in the given stream can be parsed as an integer
     */
    private boolean isAllNumeric(TokenStream stream) {
        List<Token> tokens = ((NattyTokenSource) stream.getTokenSource()).getTokens();
        for (Token token : tokens) {
            try {
                Integer.parseInt(token.getText());
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return true;
    }

    /**
     * Parses the token stream for a SINGLE date time alternative. This method
     * assumes that the entire token stream represents date and or time
     * information (no extraneous tokens)
     *
     * @param TokenStream object, the full text and date reference
     */
    private DateGroup singleParse(TokenStream stream, String fullText, Date referenceDate) {
        DateGroup group = null;
        List<Token> tokens = ((NattyTokenSource) stream.getTokenSource()).getTokens();
        if (tokens.isEmpty()) {
            return group;
        }

        StringBuilder tokenString = new StringBuilder();
        for (Token token : tokens) {
            tokenString.append(DateParser.tokenNames[token.getType()]);
            tokenString.append(" ");
        }

        try {
            ParseListener listener = new ParseListener();
            DateParser parser = new DateParser(stream, listener);
            DateParser.parse_return parseReturn = parser.parse();

            Tree tree = (Tree) parseReturn.getTree();

            // continue if a meaningful syntax tree has been built
            if (tree.getChildCount() > 0) {
                logger.info("PARSE: " + tokenString.toString());

                // rewrite the tree
                CommonTreeNodeStream nodes = new CommonTreeNodeStream(tree);
                TreeRewrite s = new TreeRewrite(nodes);
                tree = (CommonTree) s.downup(tree);
                nodes = new CommonTreeNodeStream(tree);
                nodes.setTokenStream(stream);
                DateWalker walker = new DateWalker(nodes);
                walker.setReferenceDate(referenceDate);
                walker.getState().setDefaultTimeZone(defaultTimeZone);
                walker.parse();
                logger.info("AST: " + tree.toStringTree());

                // run through the results and append the parse information
                group = walker.getState().getDateGroup();
                ParseLocation location = listener.getDateGroupLocation();
                group.setLine(location.getLine());
                group.setText(location.getText());
                group.setPosition(location.getStart());
                group.setSyntaxTree(tree);
                group.setParseLocations(listener.getLocations());
                group.setFullText(fullText);

                String prefix = group.getPrefix(1);
                String suffix = group.getSuffix(1);
                // ignore this result if the group's matching text has an immediate alphabetic
                // prefix or suffix
                if ((!prefix.isEmpty() && Character.isLetter(prefix.charAt(0)))
                        || (!suffix.isEmpty() && Character.isLetter(suffix.charAt(0)))) {
                    group = null;
                }
            }
        } catch (RecognitionException e) {
            logger.debug("Could not parse input", e);
        }

        return group;
    }

    /**
     * Scans the given token global token stream for a list of sub-token streams
     * representing those portions of the global stream that may contain date
     * time information
     *
     * @param TokenStream stream
     * @return list of token stream
     */
    private List<TokenStream> collectTokenStreams(TokenStream stream) {

        // walk through the token stream and build a collection
        // of sub token streams that represent possible date locations
        List<Token> currentGroup = null;
        List<List<Token>> groups = new ArrayList<List<Token>>();
        Token currentToken;
        int currentTokenType;
        StringBuilder tokenString = new StringBuilder();
        while ((currentToken = stream.getTokenSource().nextToken()).getType() != DateLexer.EOF) {
            currentTokenType = currentToken.getType();
            tokenString.append(DateParser.tokenNames[currentTokenType]).append(" ");

            if (currentGroup == null) {
                // skip over white space and known tokens that cannot be the start of a date
                if (currentTokenType != DateLexer.WHITE_SPACE
                        && DateParser.FOLLOW_empty_in_parse186.member(currentTokenType)) {

                    currentGroup = new ArrayList<Token>();
                    currentGroup.add(currentToken);
                }
            } else { // collect and preserve white space
                if (currentTokenType == DateLexer.WHITE_SPACE) {
                    currentGroup.add(currentToken);
                } else {
                    // if this is an unknown token, close out the current group
                    if (currentTokenType == DateLexer.UNKNOWN) {
                        addGroup(currentGroup, groups);
                        currentGroup = null;
                    } else {
                        // token is known and add it to the current group
                        currentGroup.add(currentToken);
                    }
                }
            }
        }

        if (currentGroup != null) {
            addGroup(currentGroup, groups);
        }

        // add information to logger
        logger.info("STREAM: " + tokenString.toString());
        List<TokenStream> streams = new ArrayList<TokenStream>();
        for (List<Token> group : groups) {
            if (!group.isEmpty()) {
                StringBuilder builder = new StringBuilder();
                builder.append("GROUP: ");
                for (Token token : group) {
                    builder.append(DateParser.tokenNames[token.getType()]).append(" ");
                }
                logger.info(builder.toString());

                streams.add(new CommonTokenStream(new NattyTokenSource(group)));
            }
        }

        return streams;
    }

    /**
     * Cleans up the given group and adds it to the list of groups if still
     * valid
     */
    private void addGroup(List<Token> group, List<List<Token>> groups) {

        if (group.isEmpty()) {
            return;
        }

        // remove trailing tokens that should be ignored
        while (!group.isEmpty() && IGNORED_TRAILING_TOKENS.contains(group.get(group.size() - 1).getType())) {
            group.remove(group.size() - 1);
        }

        // if the group still has some tokens left, add it to our list of groups
        if (!group.isEmpty()) {
            groups.add(group);
        }
    }
}
```
###### \java\seedu\address\logic\dateparser\DateTimeParser.java
``` java
/**
 * The API of the DateTimeParser component.
 */
public interface DateTimeParser {

    /**
     * Parses the given input value to the DateTimeParser
     */
    List<DateGroup> parse(String value);

}
```
###### \java\seedu\address\logic\LogicManager.java
``` java
    @Override
    public CommandResult execute(String commandText) throws CommandException {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText);
        command.setData(model);
        command.setDateParser(dtParser);
        command.setRecurrenceParser(recurrenceParser);
        return command.execute();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredIncompleteTaskList() {
        return model.getFilteredIncompleteTaskList();
    }
}
```
###### \java\seedu\address\logic\parser\AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser extends Parser {

    public static final int START_STRING_INDEX = 0;
    public static final int VALID_DATEARR_SIZE = 1;

    /**
     * Parses the given {@code String} of arguments in the context of the
     * AddCommand and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_LABEL);
        argsTokenizer.tokenize(args);
        try {
            String title = argsTokenizer.getPreamble().get();

            if (args.contains(PREFIX_TIMEINTERVAL_START.getPrefix())
                    && args.contains(PREFIX_TIMEINTERVAL_END.getPrefix())) {
                argsTokenizer = new ArgumentTokenizer(PREFIX_TIMEINTERVAL_START, PREFIX_TIMEINTERVAL_END, PREFIX_LABEL,
                        PREFIX_RECURRENCE);
                argsTokenizer.tokenize(args);
                String startDT = argsTokenizer.getValue(PREFIX_TIMEINTERVAL_START).get();
                String endDT = argsTokenizer.getValue(PREFIX_TIMEINTERVAL_END).get();
                Boolean isRecurring = false;

                if (isDateParseable(startDT) && isDateParseable(endDT)) {
```
###### \java\seedu\address\logic\parser\BookCommandParser.java
``` java
/**
* Parses input arguments and creates a new BookCommand object
*/
public class BookCommandParser extends Parser {

    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_BOOK_DATE, PREFIX_LABEL);
        argsTokenizer.tokenize(args);
        try {
            String title = argsTokenizer.getPreamble().get();
            return new BookCommand(title,
                    ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_LABEL)),
                    argsTokenizer.getValue(PREFIX_BOOK_DATE).get().split(DateTimeUtil.DATE_DELIMITER));
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, BookCommand.MESSAGE_USAGE));
        } catch (Exception e) {
            return new IncorrectCommand(e.getMessage());
        }
    }
}
```
###### \java\seedu\address\logic\parser\ConfirmCommandParser.java
``` java
/**
* Parses input arguments and creates a new ConfirmCommand object
*/
public class ConfirmCommandParser extends Parser {

    private static final String DELIMITER = " ";
    private static final int ARGUMENT_LENGTH = 2;
    private static final int BOOKING_SLOT_INDEX = 1;
    private static final int INVALID_INDEX = -1;
    private static final int TASK_INDEX = 0;
    private static final int VALID_INDEX = 0;
    private static final String REGEX_INDEX = "^[0-9]*";

    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);
        try {
            String[] arguments = argsTokenizer.getPreamble().get().trim().split(DELIMITER);
            if (arguments.length != ARGUMENT_LENGTH) {
                throw new CommandException(ConfirmCommand.MESSAGE_USAGE);
            }

            if (arguments[TASK_INDEX].matches(REGEX_INDEX)
                    && arguments[BOOKING_SLOT_INDEX].matches(REGEX_INDEX)) {
                int filteredTaskListIndex = tryParseAsIndex(arguments[TASK_INDEX]);
                int bookingSlotIndex = tryParseAsIndex(arguments[BOOKING_SLOT_INDEX]);
                if (filteredTaskListIndex > VALID_INDEX && bookingSlotIndex > VALID_INDEX) {
                    return new ConfirmCommand(filteredTaskListIndex, bookingSlotIndex);
                } else {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
                }
            } else {
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
            }
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        } catch (Exception e) {
            return new IncorrectCommand(Messages.MESSAGE_INVALID_TASKS_DISPLAYED_INDEX);
        }
    }

    /**
     * Try parsing arguments as index
     */
    private int tryParseAsIndex(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (index.isPresent()) {
            return index.get();
        } else {
            return INVALID_INDEX;
        }
    }
}
```
###### \java\seedu\address\logic\parser\EditBookingCommandParser.java
``` java
/**
* Parses input arguments and creates a new EditBookingCommand object
*/
public class EditBookingCommandParser {

    private static final String DELIMITER = " ";
    private static final int ARGUMENT_LENGTH = 3;
    private static final int ACTION_INDEX = 1;
    private static final int BOOKING_SLOT_INDEX = 2;
    private static final int INVALID_INDEX = -1;
    private static final int TASK_INDEX = 0;
    private static final int VALID_INDEX = 0;
    private static final String REGEX_INDEX = "^[0-9]*";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditLabelCommand and returns an EditLabelCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);
        try {
            String[] arguments = argsTokenizer.getPreamble().get().trim().split(DELIMITER);
            if (arguments.length < ARGUMENT_LENGTH) {
                throw new CommandException(ConfirmCommand.MESSAGE_USAGE);
            }

            if (arguments[TASK_INDEX].matches(REGEX_INDEX)) {
                if (PREFIX_BOOK_ADD_DATE.getPrefix().equalsIgnoreCase(arguments[ACTION_INDEX])) {
                    argsTokenizer = new ArgumentTokenizer(PREFIX_BOOK_ADD_DATE);
                    argsTokenizer.tokenize(args);
                    String[] dates = argsTokenizer.getValue(PREFIX_BOOK_ADD_DATE)
                            .get().trim().split(DateTimeUtil.DATE_DELIMITER);
                    return new EditBookingCommand(tryParseAsIndex(arguments[TASK_INDEX]), dates);
                } else if (PREFIX_BOOK_REMOVE_DATE.getPrefix().equalsIgnoreCase(arguments[ACTION_INDEX])) {
                    if (arguments[BOOKING_SLOT_INDEX].matches(REGEX_INDEX)) {
                        int bookingSlotIndex = tryParseAsIndex(arguments[BOOKING_SLOT_INDEX]);
                        int listIndex = tryParseAsIndex(arguments[TASK_INDEX]);
                        return new EditBookingCommand(listIndex, bookingSlotIndex);
                    }
                } else if (PREFIX_BOOK_CHANGE_DATE.getPrefix().equalsIgnoreCase(arguments[ACTION_INDEX])) {
                    if (arguments[BOOKING_SLOT_INDEX].matches(REGEX_INDEX)) {
                        String[] input = args.split(arguments[ACTION_INDEX] + " " + arguments[BOOKING_SLOT_INDEX]);
                        int bookingSlotIndex = tryParseAsIndex(arguments[2]);
                        int listIndex = tryParseAsIndex(arguments[TASK_INDEX]);
                        if (bookingSlotIndex > VALID_INDEX && listIndex > VALID_INDEX) {
                            return new EditBookingCommand(listIndex,
                                    bookingSlotIndex,
                                    input[ACTION_INDEX]);
                        }
                    }
                } else {
                    return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                            EditBookingCommand.MESSAGE_USAGE));
                }
            } else {
                throw new CommandException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                        EditBookingCommand.MESSAGE_USAGE));
            }
        } catch (Exception e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    EditBookingCommand.MESSAGE_USAGE));
        }
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                EditBookingCommand.MESSAGE_USAGE));
    }

    /**
     * Try parsing arguments as index
     */
    private int tryParseAsIndex(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (index.isPresent()) {
            return index.get();
        } else {
            return INVALID_INDEX;
        }
    }

}
```
###### \java\seedu\address\logic\parser\FindCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FindCommand object
 */
public class FindCommandParser extends Parser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * FindCommand and returns an FindCommand object for execution.
     */
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        try {
            ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_DEADLINE,
                    PREFIX_TIMEINTERVAL_START, PREFIX_TIMEINTERVAL_END);
            argsTokenizer.tokenize(args);
            if (args.trim().contains(PREFIX_TIMEINTERVAL_START.getPrefix())
                    && args.trim().contains(PREFIX_TIMEINTERVAL_END.getPrefix())) {
                return new FindCommand(argsTokenizer.getValue(PREFIX_TIMEINTERVAL_START).get(),
                        argsTokenizer.getValue(PREFIX_TIMEINTERVAL_END).get());
            } else if (args.trim().contains(PREFIX_DEADLINE.getPrefix())) {
                return new FindCommand(argsTokenizer.getValue(PREFIX_DEADLINE).get());
            }
        } catch (Exception e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

}
```
###### \java\seedu\address\logic\parser\ListCommandParser.java
``` java
/**
* Parses input arguments and creates a new ListCommand object
*/
public class ListCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * FindCommand and returns an FindCommand object for execution.
     */
    public Command parse(String args) {
        try {
            ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_DEADLINE,
                    PREFIX_TIMEINTERVAL_START, PREFIX_TIMEINTERVAL_END, PREFIX_STATUS_COMPLETED,
                    PREFIX_STATUS_INCOMPLETE);
            argsTokenizer.tokenize(args);
            if (args.trim().contains(PREFIX_TIMEINTERVAL_START.getPrefix())
                    && args.trim().contains(PREFIX_TIMEINTERVAL_END.getPrefix())) {
                return new ListCommand(argsTokenizer.getValue(PREFIX_TIMEINTERVAL_START).get(),
                        argsTokenizer.getValue(PREFIX_TIMEINTERVAL_END).get());
            } else if (args.trim().contains(PREFIX_DEADLINE.getPrefix())) {
                return new ListCommand(argsTokenizer.getValue(PREFIX_DEADLINE).get());
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    public boolean isDateParseable(String input) {
        return !dtParser.parse(input).isEmpty();
    }

```
###### \java\seedu\address\logic\undo\Undo.java
``` java
/**
 * Interface for undo command
 */
public interface Undo {

    /**
     * Undoes an command executed previously
     * @return UndoPair which contains the previous tasks and labels
     */
    UndoPair<ObservableList<ReadOnlyTask>, ObservableList<Label>> getUndoData();

    /**
     * Add old task state and old label state into undo storage history
     * @param currentTaskState - before execution
     * @param currentLabel - before execution
     */
    void addStorageHistory(ObservableList<ReadOnlyTask> currentTaskState, ObservableList<Label> currentLabelState);

    /**
     * Return true if the undo data structure is empty and false otherwise
     */
    boolean isEmpty();

    /**
     * Clears the data in the undo data structure
     */
    void clear();
}
```
###### \java\seedu\address\logic\undo\UndoManager.java
``` java
/**
 * A singleton UndoManager that implements a linkedlist of undoPair objects which essentially stores the data
 */
public class UndoManager implements Undo {

    private static UndoManager instance = null;
    private LinkedList<UndoPair<ObservableList<ReadOnlyTask>, ObservableList<Label>>> storageHistory;

    private UndoManager() {
        storageHistory = new LinkedList<UndoPair<ObservableList<ReadOnlyTask>, ObservableList<Label>>>();
    }

    public static UndoManager getInstance() {
        if (instance == null) {
            instance = new UndoManager();
        }
        return instance;
    }

    public void addStorageHistory(ObservableList<ReadOnlyTask> currentTasks, ObservableList<Label> currentLabels) {
        this.storageHistory.addLast(
                new UndoPair<ObservableList<ReadOnlyTask>,
                ObservableList<Label>>(currentTasks, currentLabels));
    }

    public boolean isEmpty() {
        return storageHistory.isEmpty();
    }

    public void clear() {
        storageHistory.clear();
    }

    @Override
    public UndoPair<ObservableList<ReadOnlyTask>, ObservableList<Label>> getUndoData() {
        return storageHistory.removeLast();
    }

}
```
###### \java\seedu\address\model\booking\Booking.java
``` java
/**
 * Represents a booking in DoOrDie Task Manager Application
 * Guarantees: immutable; dates are valid as declared in {@link #isDateParsable(String)}
 */
public class Booking implements Comparable<Booking> {

    public static final String MESSAGE_BOOKING_CONSTRAINTS =
            "Input dates are in the wrong format, please try again!";
    private static DateTimeParser dtParser;

    public boolean confirm;
    public Date startTime;
    public Date endTime;

    public Booking(String date) throws CommandException {
        dtParser = new DateTimeManager();
        if (isDateParseable(date)) {
            List<DateGroup> dateList = dtParser.parse(date);
            if (dateList.get(0).getDates().size() > 1) {
                this.startTime = dateList.get(0).getDates().get(0);
                this.endTime = dateList.get(0).getDates().get(1);
            } else {
                throw new CommandException(MESSAGE_BOOKING_CONSTRAINTS);
            }
        }
    }

    public Booking(Date startDate, Date endDate) {
        dtParser = new DateTimeManager();
        this.startTime = startDate;
        this.endTime = endDate;
    }

    public Date getBookingStartDate() {
        return this.startTime;
    }

    public Date getBookingEndDate() {
        return this.endTime;
    }

    public boolean isDateParseable(String date) {
        return !dtParser.parse(date).isEmpty();
    }

    /**
     * Format state as text for viewing.
     */
    public String toString() {
        SimpleDateFormat df = new SimpleDateFormat("EEE dd MMM yyyy h:mm a");
        return df.format(startTime).toString() + " - " + df.format(endTime).toString() + " ";
    }

    @Override
    public int compareTo(Booking compareObj) {
        return this.getBookingStartDate().compareTo(compareObj.getBookingStartDate());
    }

}
```
###### \java\seedu\address\model\booking\UniqueBookingList.java
``` java
/**
 * A list of bookings that enforces no nulls and uniqueness between its elements.
 *
 * Supports minimal set of list operations for the app's features.
 *
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueBookingList implements Iterable<Booking>, Cloneable {
    private final ObservableList<Booking> internalList = FXCollections.observableArrayList();

    /**
     * Constructs empty BookingList.
     */
    public UniqueBookingList() {}

    /**
     * Creates a UniqueBookingList using given String bookings. Enforces no nulls or
     * duplicates.
     * @throws CommandException
     */
    public UniqueBookingList(String... bookings)
            throws DuplicateBookingException, IllegalValueException, CommandException {
        final List<Booking> bookingList = new ArrayList<Booking>();
        for (String booking : bookings) {
            bookingList.add(new Booking(booking));
        }
        sortBooklingList(bookingList);
        setBookings(bookingList);
    }

    /**
     * Creates a UniqueBookingList using given bookings. Enforces no nulls or
     * duplicates.
     */
    public UniqueBookingList(Booking... booking) throws DuplicateBookingException {
        assert !CollectionUtil.isAnyNull((Object[]) booking);
        final List<Booking> initialBookings = Arrays.asList(booking);
        if (!CollectionUtil.elementsAreUnique(initialBookings)) {
            throw new DuplicateBookingException();
        }
        sortBooklingList(initialBookings);
        internalList.addAll(initialBookings);
    }

    /**
     * Creates a UniqueBookingList using given bookings. Enforces no null or
     * duplicate elements.
     * @throws DuplicateBookingException
     */
    public UniqueBookingList(Collection<Booking> bookings) throws DuplicateBookingException {
        this();
        setBookings(bookings);
    }

    /**
     * Creates a UniqueBookingList using given bookings. Enforces no nulls.
     */
    public UniqueBookingList(Set<Booking> bookings) {
        assert !CollectionUtil.isAnyNull(bookings);
        final List<Booking> bookingList = new ArrayList<Booking>(bookings);
        sortBooklingList(bookingList);
        internalList.addAll(bookingList);
    }

    /**
     * Creates a copy of the given list. Insulates from changes in source.
     */
    public UniqueBookingList(UniqueBookingList source) {
        internalList.addAll(source.internalList);
    }

    /**
     * Returns all bookings in this list as a Set. This set is mutable and
     * change-insulated against the internal list.
     */
    public Set<Booking> toSet() {
        return new HashSet<>(internalList);
    }

    /**
     * Returns all bookings in this list as a List. This set is mutable and
     * change-insulated against the internal list.
     */
    public ArrayList<Booking> toList() {
        return new ArrayList<Booking>(internalList);
    }

    /**
     * Replaces the Tags in this list with those in the argument booking list.
     */
    public void setBookings(UniqueBookingList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setBookings(Collection<Booking> bookings) throws DuplicateBookingException {
        assert !CollectionUtil.isAnyNull(bookings);
        if (!CollectionUtil.elementsAreUnique(bookings)) {
            throw new DuplicateBookingException();
        }
        internalList.setAll(bookings);
    }

    /**
     * Removes all bookings from the list. Warning, this cannot be undone!
     */
    public void removeAll() {
        internalList.clear();
    }

    @Override
    public UniqueBookingList clone() {
        UniqueBookingList bookingList = new UniqueBookingList();
        try {
            for (Booking booking : internalList) {
                bookingList.add(new Booking(booking.getBookingStartDate(), booking.getBookingEndDate()));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return bookingList;
    }

    /**
     * Ensures every booking in the argument list exists in this object.
     */
    public void mergeFrom(UniqueBookingList from) {
        final Set<Booking> alreadyInside = this.toSet();
        from.internalList.stream().filter(booking -> !alreadyInside.contains(booking)).forEach(internalList::add);
    }

    /**
     * Returns true if the list contains an equivalent Booking as the given
     * argument.
     */
    public boolean contains(Booking toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Returns true if the booking list contains an equivalent booking as the given
     * argument.
     */
    public boolean containsStringBooking(Booking bookingToCheck) {
        assert bookingToCheck != null;
        for (Booking booking : internalList) {
            if (booking.getBookingStartDate().equals(bookingToCheck.getBookingStartDate())
                    && booking.getBookingEndDate().equals(bookingToCheck.getBookingEndDate())) {
                return true;
            }
        }
        return false;
    }

    /**
     * Adds a booking to the list.
     *
     * @throws DuplicateBookingException
     *             if the booking to add is a duplicate of an existing booking in
     *             the list.
     */
    public void add(Booking toAdd) throws DuplicateBookingException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateBookingException();
        }
        internalList.add(toAdd);
    }

    @Override
    public Iterator<Booking> iterator() {
        return internalList.iterator();
    }

    public UnmodifiableObservableList<Booking> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueBookingList // instanceof handles nulls
                        && this.internalList.equals(((UniqueBookingList) other).internalList));
    }

    public boolean equalsOrderInsensitive(UniqueBookingList other) {
        return this == other || new HashSet<>(this.internalList).equals(new HashSet<>(other.internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    public boolean isEmpty() {
        return internalList.isEmpty();
    }

    private void sortBooklingList(List<Booking> bookingList) {
        Collections.sort(bookingList);
    }

    /**
     * Signals that an operation would have violated the 'no duplicates'
     * property of the list.
     */
    public static class DuplicateBookingException extends DuplicateDataException {
        protected DuplicateBookingException() {
            super("Operation would result in duplicate bookings");
        }
    }

```
###### \java\seedu\address\model\Cloneable.java
``` java
public interface Cloneable <T> {
    public T clone();
}
```
###### \java\seedu\address\model\datastructure\PartialSearch.java
``` java
/**
 * This class will handle the partial search algorithm and the search function itself
 */
public class PartialSearch {

    private final Set<String> infixes = new HashSet<>();

    private String itemToSearch;

    public PartialSearch(String itemToSearch) {
        this.itemToSearch = itemToSearch;
        prepareSearch();
    }

    /**
     * This method prepares the infix set for search
     */
    public void prepareSearch() {
        for (int i = 0; i < itemToSearch.length(); i++) {
            for (int j = i + 1; j <= itemToSearch.length(); j++) {
                infixes.add(itemToSearch.substring(i, j).toLowerCase());
            }
        }
    }

    /**
     * This method does the search by matching the hash set for match
     * @param searchString
     * @return true if exist and false if otherwise
     */
    public boolean search(String searchString) { // O(1) search
        return infixes.contains(searchString.toLowerCase());
    }
}
```
###### \java\seedu\address\model\datastructure\UndoPair.java
``` java
/**
 * This class stores the command and the list of task as a pair
 */
public class UndoPair<Command, Data> {
    private final Command left;
    private final Data right;

    public UndoPair(Command left, Data right) {
        this.left = left;
        this.right = right;
    }

    public Command getLeft() {
        return this.left;
    }

    public Data getRight() {
        return this.right;
    }

    @Override
    public int hashCode() {
        return left.hashCode() ^ right.hashCode();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof UndoPair)) {
            return false;
        }
        UndoPair pair = (UndoPair) o;
        return this.left.equals(pair.getLeft()) && this.right.equals(pair.getRight());
    }
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    /** Raises an event to indicate the model has changed */
    private void focusOnListIndex(int index) {
        raise(new JumpToListRequestEvent(index));
    }

    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        taskManager.removeTask(target);
        indicateTaskManagerChanged();
    }

```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        taskManager.addTask(task);
        indicateTaskManagerChanged();
        setScrollToTask(task);
    }

```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedTask != null;
        int taskManagerIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        taskManager.updateTask(taskManagerIndex, editedTask);
        indicateTaskManagerChanged();
        setScrollToTask(editedTask);
    }

```
###### \java\seedu\address\model\ModelManager.java
``` java
    /**
     * This method will find the index of the task in the filtered list
     */
    private void setScrollToTask(ReadOnlyTask task) {
        int indexInFilteredTask = filteredTasks.indexOf(task);
        if (indexInFilteredTask < 0) {
            updateFilteredListToShowAll();
            indexInFilteredTask = filteredTasks.indexOf(task);
        }
        focusOnListIndex(indexInFilteredTask);
    }

```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void undoPrevious(ObservableList<ReadOnlyTask> oldTaskState, ObservableList<Label> oldLabelState)
            throws InvalidUndoCommandException {
        taskManager.undoData(oldTaskState, oldLabelState);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    //=========== Filtered Task List Accessors =============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        sortFilteredTasks();
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredIncompleteTaskList() {
        updateFilteredTaskList(false);
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public void updateFilteredListToShowAll() {
        updateFilteredTaskList(false);
    }

    @Override
    public void updateFilteredTaskList(Date startDate, Date endDate) {
        updateFilteredTaskListByDate(new DateFilter(startDate, endDate));
    }

    @Override
    public void updateFilteredTaskList(Date startDate, Date endDate, boolean completeStatus) {
        updateFilteredTaskListByDate(new DateFilterCompleted(startDate, endDate, completeStatus));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
        sortFilteredTasks();
    }

    @Override
    public void updateFilteredTaskList(Boolean isCompleted) {
        updateFilteredTaskListByCompletion(new StatusFilter(isCompleted));
        sortFilteredTasks();
    }

    private void updateFilteredTaskListByDate(DateFilter dateFilter) {
        filteredTasks.setPredicate(dateFilter::run);
    }

    private void updateFilteredTaskListByDate(DateFilterCompleted dateFilter) {
        filteredTasks.setPredicate(dateFilter::run);
    }

    private void updateFilteredTaskListByCompletion(StatusFilter statusFilter) {
        filteredTasks.setPredicate(statusFilter::run);
    }

    //========== Inner classes/interfaces used for filtering =================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);
        String toString();
    }

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

```
###### \java\seedu\address\model\ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            String taskDetails = task.getAsSearchText();
            PartialSearch partialSearch = new PartialSearch(taskDetails);
            return (nameKeyWords.stream()
                    .filter(keyword -> partialSearch.search(keyword))
                    .findAny()
                    .isPresent());
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

    private class DateFilterCompleted {
        private Date startTime;
        private Date endTime;
        private boolean isCompleted;

        DateFilterCompleted(Date startTime, Date endTime, boolean isCompleted) {
            this.startTime = startTime;
            this.endTime = endTime;
            this.isCompleted = isCompleted;
        }

        public boolean run(ReadOnlyTask task) {
            if (task.getDeadline().isPresent() && task.getStartTime().isPresent()) {
                return isCompleted == task.isCompleted() &&
                        (task.getDeadline().get().getDateTime().before(endTime)
                        && task.getDeadline().get().getDateTime().after(startTime))
                        || task.getDeadline().get().getDateTime().equals(endTime);
            } else if (task.getDeadline().isPresent()) {
                return isCompleted == task.isCompleted()
                        && (task.getDeadline().get().getDateTime().before(endTime)
                        || task.getDeadline().get().getDateTime().equals(endTime));
            }
            return false;
        }
    }

```
###### \java\seedu\address\model\ModelManager.java
``` java
    private class DateFilter {
        private Date startTime;
        private Date endTime;

        DateFilter(Date startTime, Date endTime) {
            this.startTime = startTime;
            this.endTime = endTime;
        }

        public boolean run(ReadOnlyTask task) {
            if (task.getDeadline().isPresent() && task.getStartTime().isPresent()) {
                return (task.getDeadline().get().getDateTime().before(endTime)
                        && task.getDeadline().get().getDateTime().after(startTime))
                        || task.getDeadline().get().getDateTime().equals(endTime);
            } else if (task.getDeadline().isPresent()) {
                return task.getDeadline().get().getDateTime().before(endTime)
                        || task.getDeadline().get().getDateTime().equals(endTime);
            }
            return false;
        }
    }

```
###### \java\seedu\address\model\task\Deadline.java
``` java
    /**
     * Validates given deadline.
     *
     * @throws IllegalValueException
     *             if given deadline string is invalid.
     * @throws IllegalDateTimeValueException
     *             if given deadline could be parse to a valid date
     */
    public Deadline(String strDeadline) throws IllegalValueException, IllegalDateTimeValueException {
        assert strDeadline != null;
        if (!isValidDeadline(strDeadline)) {
            throw new IllegalValueException(MESSAGE_DEADLINE_CONSTRAINTS);
        } else {
            if (!isEmptyDeadline(strDeadline)) {
                try {
                    List<Date> dateList;
                    if (dateParser.parse(strDeadline).get(0).isTimeInferred()) {
                        dateList = dateParser.parse(strDeadline + " " + DEFAULT_ENDTIME).get(0).getDates();
                    } else {
                        dateList = dateParser.parse(strDeadline).get(0).getDates();
                    }

                    if (dateList != null && dateList.size() > 0) {
                        this.deadline = dateList.get(0);
                        this.value = deadline.toString();
                    }
                } catch (Exception e) {
                    throw new IllegalDateTimeValueException();
                }
            } else {
                value = "";
            }
        }
    }

    /**
     * Returns true if a given string is a valid deadline.
     */
    public static boolean isValidDeadline(String test) {
        return test.matches(DEADLINE_VALIDATION_REGEX);
    }

    /**
     * Returns true if a given string has no date.
     */
    public static boolean isEmptyDeadline(String test) {
        return "".equals(test);
    }

    /**
     * Returns true if a given string is a valid date.
     */
    public static boolean isParsableDate(String test) {
        return !dateParser.parse(test).isEmpty();
    }

    public Date getDateTime() {
        return deadline;
    }

    @Override
    public String toString() {
        if ("".equals(value)) {
            return "";
        }
        SimpleDateFormat df = new SimpleDateFormat("EEE dd MMM yyyy h:mm a");
        return df.format(deadline);
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof Deadline) {
            if (this.deadline != null && ((Deadline) other).deadline != null) {
                return other == this // short circuit if same object
                        || (other instanceof Deadline // instanceof handles nulls
                                && this.deadline.equals(((Deadline) other).deadline)); // state check
            } else {
                return true;
            }
        }
        return false;
    }

    @Override
    public int hashCode() {
        return deadline.hashCode();
    }

}
```
###### \java\seedu\address\ui\LabelCard.java
``` java
/**
 * LabelCard controller for each individual label on the Left Panel
 */
public class LabelCard extends UiPart<Region> {
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);

    private static final String FXML = "LabelCard.fxml";

    @FXML
    private Label labelText;

    @FXML
    private FontAwesomeIconView icon;

    @FXML
    private Label taskCountText;

    public LabelCard(seedu.address.model.label.Label labels, int count) {
        super(FXML);
        initLabel(labels, count);
    }

```
###### \java\seedu\address\ui\LabelCard.java
``` java
    /**
     * Event handler for label list selection
     */
    @FXML
    private void handleLabelClicked() {
        logger.fine("Selection in label left list panel changed to : '" + labelText.getText() + "'");
        raise(new LeftPanelSelectionChangedEvent(labelText.getText()));
    }
}
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    /**
     * Display task with the label selected
     */
    public void loadLabelSelection(String label) {
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(label));
        model.updateFilteredTaskList(keywordSet);
    }

    /**
     * Updates task list with tasks that starts after today
     */
    public void loadTodaySelection() {
        Date endDate = DateTimeUtil.getEndDate();
        Date startDate = DateTimeUtil.getStartDate();
        model.updateFilteredTaskList(startDate, endDate, false);
    }

    /**
     * Display all incomplete task
     */
    public void showAllTask() {
        model.updateFilteredTaskList(false);
    }

    public TaskListPanel getTaskListPanel() {
        return this.taskListPanel;
    }

    public void setLogic(Logic logic) {
        this.logic = logic;
    }

    public void setModel(Model model) {
        this.model = model;
    }
}
```
###### \java\seedu\address\ui\TaskCard.java
``` java
/**
 * This class handles the initialization of the task card in task list panel
 */
public class TaskCard extends UiPart<Region> {

    private static final String FXML = "TaskListCard.fxml";
    private static final int INVALID_INDEX = -1;
    private static final int VALID_INDEX = 0;

    @FXML
    private HBox cardPane;
    @FXML
    private VBox vBoxMain;
    @FXML
    private VBox leftVBox;
    @FXML
    private CheckBox completedCB;
    @FXML
    private Label title;
    @FXML
    private Label id;
    @FXML
    private VBox dateVBox;
    @FXML
    private Label startTime;
    @FXML
    private Label dashLabel;
    @FXML
    private Label deadline;
    @FXML
    private Label status;
    @FXML
    private javafx.scene.control.Label reserveSlot;
    @FXML
    private FlowPane labels;
    @FXML
    private FlowPane bookings;
    @FXML
    private Label recurrence;

    /**
     * Task Card initialization
     */
    public TaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        title.setText(task.getTitle().title);
        id.setText(displayedIndex + ". ");
        setStartTime(task);
        setDeadline(task);
        setLabel(task);
        setBookings(task);
        removeStatus();
        setCheckBox(task, displayedIndex);
        setDashLabel(task);
        setIsRecurringLabel(task);
    }

    /**
     * Set the recurring label text
     */
    private void setIsRecurringLabel(ReadOnlyTask task) {
        if (task.isRecurring()) {
            recurrence.setText("Repeats every " + task.getRecurrence().get().toString());
        } else {
            dateVBox.getChildren().remove(recurrence);
        }
    }

    /**
     * Set dash label to display only when both start date and deadline is present
     */
    private void setDashLabel(ReadOnlyTask task) {
        if (!(task.getStartTime().isPresent() && task.getDeadline().isPresent())) {
            dateVBox.getChildren().remove(dashLabel);
        }
    }

    /**
     * Initialize the checkbox and stores the display index in the style of checkbox
     */
    private void setCheckBox(ReadOnlyTask task, int displayedIndex) {
        completedCB.setStyle(displayedIndex + "");
        completedCB.setSelected(task.isCompleted());
        if (task.isRecurring() && task.isCompleted()) {
            completedCB.setDisable(true);
        }
    }

    /**
     * Initialize the start time. If start time is present, display,
     * else dynamically delete the start time label from parent
     */
    private void setStartTime(ReadOnlyTask task) {
        if (task.getStartTime().isPresent()) {
            startTime.setText(task.getStartTime().get().toString());
        } else {
            dateVBox.getChildren().remove(startTime);
        }
    }

    /**
     * Initialize the deadline. If deadline is present, display,
     * else dynamically delete the deadline label from parent
     */
    private void setDeadline(ReadOnlyTask task) {
        if (task.getDeadline().isPresent()) {
            deadline.setText(task.getDeadline().get().toString());
        } else {
            dateVBox.getChildren().remove(deadline);
        }
    }

    /**
     * Initialize the labels panel. If there exist label, display,
     * else dynamically delete the label flow pane from parent
     */
    private void setLabel(ReadOnlyTask task) {
        if (task.getLabels().isEmpty()) {
            leftVBox.getChildren().remove(labels);
        } else {
            initLabels(task);
        }
    }

    /**
     * Initialize the deadline. If deadline is present, display,
     * else dynamically delete the deadline label from parent
     */
    private void setBookings(ReadOnlyTask task) {
        if (task.getBookings().isEmpty()) {
            dateVBox.getChildren().remove(reserveSlot);
            dateVBox.getChildren().remove(bookings);
        } else {
            reserveSlot.setText("Reserved Slots");
            completedCB.setDisable(true);
            initBookings(task);
        }
    }

    /**
     * Remove the status label from task card
     */
    private void removeStatus() {
        vBoxMain.getChildren().remove(status);
    }

    /**
     * Event handler for check box selection
     */
    @FXML
    private void handleCheckBoxChanged(ActionEvent event) {
        int id = tryParseAsIndex(completedCB.getStyle());
        if (id > VALID_INDEX) {
            raise(new CheckBoxSelectionChangedEvent(id, completedCB.isSelected()));
        }
    }

    /**
     * Try parsing arguments as index
     */
    private int tryParseAsIndex(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (index.isPresent()) {
            return index.get();
        } else {
            return INVALID_INDEX;
        }
    }

    /**
     * Add the label flowpane with the labels in the task
     */
    private void initLabels(ReadOnlyTask task) {
        task.getLabels().forEach(label -> labels.getChildren().add(new Label(label.labelName)));
    }

    /**
     * Add the booking flowpane with the booking time slots in a task
     */
    private void initBookings(ReadOnlyTask task) {
        task.getBookings().forEach(booking -> bookings.getChildren().add(new Label(booking.toString() + "\n")));
    }
}
```
###### \java\seedu\address\ui\TaskListPanel.java
``` java
/**
 * Panel containing the list of tasks.
 */
public class TaskListPanel extends UiPart<Region> {
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "TaskListPanel.fxml";
    private static final double PERIMETER_DEFAULT_LENGTH = 0.0;

    @FXML
    private ListView<ReadOnlyTask> taskListView;

    /**
     * Initialization of the task list panel and
     * add the task panel to the task list place holder
     */
    public TaskListPanel(AnchorPane taskListPlaceholder, ObservableList<ReadOnlyTask> taskList) {
        super(FXML);
        setConnections(taskList);
        addToPlaceholder(taskListPlaceholder);
        setEventHandlerForSelectionChangeEvent();
    }

    /**
     * Set the connections for task list panel
     */
    public void setConnections(ObservableList<ReadOnlyTask> taskList) {
        taskListView.setItems(taskList);
        taskListView.setCellFactory(listView -> new TaskListViewCell());
    }

    private void addToPlaceholder(AnchorPane placeHolderPane) {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(),
                PERIMETER_DEFAULT_LENGTH,
                PERIMETER_DEFAULT_LENGTH,
                PERIMETER_DEFAULT_LENGTH,
                PERIMETER_DEFAULT_LENGTH);
        placeHolderPane.getChildren().add(getRoot());
    }

    /**
     * Set the event handler for selection change of the task card
     */
    private void setEventHandlerForSelectionChangeEvent() {
        taskListView.getSelectionModel().selectedItemProperty()
                .addListener((observable, oldValue, newValue) -> {
                    if (newValue != null) {
                        logger.fine("Selection in task list panel changed to : '" + newValue + "'");
                        raise(new TaskPanelSelectionChangedEvent(newValue));
                    }
                });
    }

    /**
     * Set the task list to scroll to the index in the task panel
     */
    public void scrollTo(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
            taskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(new TaskCard(task, getIndex() + 1).getRoot());
            }
        }
    }

}
```
###### \java\seedu\address\ui\UiManager.java
``` java
    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTaskListPanel().scrollTo(event.targetIndex);
    }

    @Subscribe
    private void handleLeftPanelSelectionChangedEvent(LeftPanelSelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.loadLabelSelection(event.getNewSelection());
    }

    @Subscribe
    private void handleLeftPanelTodaySelectionChangedEvent(LeftPanelTodaySelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.loadTodaySelection();
    }

    @Subscribe
    private void handleShowAllSelectionChangedEvent(ShowAllSelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.showAllTask();
    }

    @Subscribe
    private void handleCheckBoxSelectionChangedEvent(CheckBoxSelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        String status = "completed";
        if (!event.getTaskStatus()) {
            status = "incomplete";
        }
        String commandText = MarkCommand.COMMAND_WORD + " " + event.getTaskIndex() + " " + status;
        try {
            logic.execute(commandText);
        } catch (CommandException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void setLogic(Logic logic) {
        this.logic = logic;
        mainWindow.setLogic(logic);
        mainWindow.fillInnerParts();
    }

    @Override
    public void setModel(Model model) {
        this.model = model;
        mainWindow.setModel(model);
    }
}
```
###### \resources\view\MainWindow.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Menu?>
<?import javafx.scene.control.MenuBar?>
<?import javafx.scene.control.MenuItem?>
<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <stylesheets>
      <URL value="@DarkTheme.css" />
   </stylesheets>
   <children>
      <MenuBar VBox.vgrow="NEVER">
         <menus>
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
               </items>
            </Menu>
         </menus>
      </MenuBar>
      <SplitPane id="splitPane" fx:id="contentSplitPane" dividerPositions="0.4" VBox.vgrow="ALWAYS">
         <items>
            <VBox maxWidth="-Infinity" minWidth="-Infinity" prefHeight="1300.0" prefWidth="300.0" style="-fx-max-width: 250; -fx-min-width: 250;" SplitPane.resizableWithParent="false">
               <children>
                  <AnchorPane fx:id="leftPanelPlaceholder" prefHeight="1300.0" prefWidth="100.0" />
               </children>
            </VBox>
            <VBox>
               <children>
                  <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border">
                     <padding>
                        <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
                     </padding>
                  </AnchorPane>
                   <AnchorPane fx:id="resultDisplayPlaceholder" maxHeight="100" minHeight="100" prefHeight="100" styleClass="anchor-pane-with-border">
                   </AnchorPane>
                  <VBox fx:id="taskList" prefHeight="1200.0">
                     <children>
                        <AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                     </children>
                  </VBox>
               </children>
            </VBox>
         </items></SplitPane>
      <AnchorPane fx:id="statusbarPlaceholder" />
   </children>
</VBox>
```
###### \resources\view\TaskListCard.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.CheckBox?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.FlowPane?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.Region?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>

<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
            </columnConstraints>
            <children>
                <VBox fx:id="vBoxMain" alignment="CENTER_LEFT" minHeight="-Infinity" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>

                    <children>
                        <HBox alignment="CENTER_LEFT" minHeight="-Infinity" prefWidth="100.0" spacing="5" VBox.vgrow="ALWAYS">
                            <children>
                        <CheckBox fx:id="completedCB" mnemonicParsing="false" onAction="#handleCheckBoxChanged">
                           <HBox.margin>
                              <Insets bottom="30.0" left="10.0" right="10.0" top="30.0" />
                           </HBox.margin></CheckBox>
                        <VBox fx:id="leftVBox" alignment="CENTER_LEFT" minHeight="-Infinity" HBox.hgrow="ALWAYS">
                           <children>
                                      <HBox alignment="CENTER_LEFT">
                                         <children>
                                             <Label fx:id="id" minWidth="-Infinity" styleClass="cell_big_label" />
                                             <Label fx:id="title" styleClass="cell_big_label" text="\$first" wrapText="true" HBox.hgrow="ALWAYS" />
                                         </children>
                                      </HBox>
                                    <FlowPane fx:id="labels" prefWrapLength="10.0" />
                           </children>
                           <HBox.margin>
                              <Insets />
                           </HBox.margin>
                        </VBox>
                        <Region maxWidth="-Infinity" prefHeight="0.0" prefWidth="20.0" HBox.hgrow="ALWAYS">
                           <HBox.margin>
                              <Insets />
                           </HBox.margin></Region>
                        <HBox alignment="CENTER_RIGHT" minHeight="-Infinity" prefWidth="200.0">
                           <children>
                              <VBox fx:id="dateVBox" alignment="CENTER_RIGHT" minWidth="-Infinity" HBox.hgrow="ALWAYS">
                                 <children>
                                    <Label fx:id="reserveSlot" alignment="CENTER_RIGHT" contentDisplay="RIGHT" textAlignment="RIGHT" />
                                          <Label fx:id="startTime" alignment="CENTER_RIGHT" contentDisplay="RIGHT" styleClass="cell_small_label" textAlignment="RIGHT" VBox.vgrow="ALWAYS" />
                                    <Label fx:id="dashLabel" text="-" />
                                          <Label fx:id="deadline" alignment="CENTER_RIGHT" contentDisplay="RIGHT" styleClass="cell_small_label" textAlignment="RIGHT" />
                                          <FlowPane fx:id="bookings" alignment="CENTER_RIGHT" columnHalignment="RIGHT" prefWrapLength="10.0" />
                                          <Label fx:id="recurrence" styleClass="cell_small_label" />
                                 </children>
                                 <HBox.margin>
                                    <Insets right="10.0" />
                                 </HBox.margin>
                              </VBox>
                           </children>
                        </HBox>
                            </children>
                        </HBox>
                        <Label fx:id="status" styleClass="cell_big_label" />
                    </children>
                </VBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
