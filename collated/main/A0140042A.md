# A0140042A
###### \java\seedu\address\commons\events\storage\FileStorageChangedEvent.java
``` java
/**
 * Loads the storage file in the given file path
 */
public class FileStorageChangedEvent extends BaseEvent {

    private String filePath;

    public FileStorageChangedEvent(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public String toString() {
        return filePath;
    }

    public String getFilePath() {
        return filePath;
    }

}
```
###### \java\seedu\address\commons\events\storage\ForceSaveEvent.java
``` java
/**
 * Saves current state into the filePath
 */
public class ForceSaveEvent extends BaseEvent {

    private String filePath;

    public ForceSaveEvent(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public String toString() {
        return filePath;
    }

    public String getFilePath() {
        return filePath;
    }

}
```
###### \java\seedu\address\logic\autocomplete\AutocompleteDataStructure.java
``` java
/**
 * Interface for data structures for auto complete manager
 */
public interface AutocompleteDataStructure {

    /**
     * Loads phrases used for auto completion into the data structure
     */
    public void load(String... phrases);

    /**
     * Finds a list of completions that can be made using the current prefix
     * @param prefix - to match against
     * @return a list of strings with auto completed suggestions
     */
    public List<String> findCompletions(String prefix);
}
```
###### \java\seedu\address\logic\autocomplete\AutocompleteManager.java
``` java
/**
 * Handles the auto-completion of the input
 */
public class AutocompleteManager {
    private final Logger logger = LogsCenter.getLogger(AutocompleteManager.class);
    public static final String[] AUTOCOMPLETE_DATA = { "help", "add", "by", "repeat", "list"
            , "edit", "find", "delete", "select", "book"
            , "confirm", "editlabel", "undo", "clear", "push"
            , "pull", "export", "exit", "to", "from", "on"
            , "hourly", "daily", "weekly", "monthly", "yearly"
            , "overdue", "outstanding", "completed", "today", "yesterday"
            , "tomorrow", "bookings", "incomplete", "confirm", "load", "saveas"};

    private AutocompleteDataStructure data;

    /**
     * Initializes auto-complete object with default auto-complete data
     */
    public AutocompleteManager() {
        this(AUTOCOMPLETE_DATA);
    }

    /**
     * Initializes auto-complete object with specified auto-complete data
     */
    public AutocompleteManager(String... data) {
        this.data = new Trie();
        this.data.load(data);
    }

    /**
     * Adds more strings for auto completion
     */
    public void addData(String... phrases) {
        data.load(phrases);
    }

    /**
     * Find auto-complete suggestions given a search term
     * @param term - search term
     * @return a list of suggestions for the given term
     */
    public AutocompleteResponse getSuggestions(AutocompleteRequest request) {
        String wordAtCursor = getWordAtCursor(request);
        List<String> suggestions = data.findCompletions(wordAtCursor);
        AutocompleteResponse response = new AutocompleteResponse(request, suggestions);
        return processRequest(response);
    }

    /**
     * Generates a new AutocompleteResponse with the new phrase, caretPosition and list of suggestions
     */
    private AutocompleteResponse processRequest(AutocompleteResponse response) {
        //if empty or matches all (AKA no match)
        if (response.getSuggestions().isEmpty() ||
                response.getSuggestions().size() == AutocompleteManager.AUTOCOMPLETE_DATA.length) {
            return response;
        }

        logger.info("Suggestions: " + response.getSuggestions());

        String longestString = getLongestString(response.getSuggestions());
        int commonSubstringIndex = getCommonSubstringEndIndexFromStart(response.getSuggestions());
        String commonSubstring = longestString.substring(0, commonSubstringIndex);

        //Append a space IF AND ONLY IF the auto-completed word is the last word of the command
        String appendCharacter = "";
        int cursorWordEndIndex = getEndIndexOfWordAtCursor(response);
        boolean endHasSpace = false;
        if (cursorWordEndIndex == response.getPhrase().trim().length() && response.getSuggestions().size() == 1) {
            //Append a space if there is a space at the end already
            if (response.getPhrase().charAt(response.getPhrase().length() - 1) != ' ') {
                appendCharacter = " ";
            }
            endHasSpace = true;
        }

        //Move position caret to after auto completed word
        String currentWord = getWordAtCursor(response);
        int newPositionCaret = cursorWordEndIndex
                               - currentWord.length()
                               + commonSubstring.length()
                               + (endHasSpace ? 1 : 0);

        response.setPhrase(replacePhraseWithSuggestion(response, commonSubstring, appendCharacter));
        response.setCaretPosition(newPositionCaret);
        return response;
    }

    /**
     * Replaces the phrase's word at the caret position with the suggestion provided
     * Appends toAppend if there is any character to append after that
     */
    private String replacePhraseWithSuggestion(AutocompleteResponse response, String suggestion, String toAppend) {
        StringBuffer commandAutocompleted = new StringBuffer(response.getPhrase());

        commandAutocompleted.replace(getStartIndexOfWordAtCursor(response),
                                        getEndIndexOfWordAtCursor(response),
                                        (suggestion + toAppend));

        return commandAutocompleted.toString();
    }


    /**
     * Returns the character index at which the characters in the list of suggestions start to differ
     */
    private int getCommonSubstringEndIndexFromStart(List<String> suggestions) {
        String longestString = getLongestString(suggestions);
        int commonSubstringIndex = 0;
        char currentChar;
        commonSubstring:
        for (int charIndex = 0; charIndex < longestString.length(); charIndex++) {
            currentChar = longestString.charAt(charIndex);
            for (String suggestion : suggestions) {
                if (suggestion.length() <= charIndex || suggestion.charAt(charIndex) != currentChar) {
                    break commonSubstring;
                }
            }
            commonSubstringIndex++;
        }
        return commonSubstringIndex;
    }

    /**
     * Returns the longest string in the list, empty string otherwise
     */
    private String getLongestString(List<String> suggestions) {
        String longest = "";
        for (String suggestion : suggestions) {
            if (suggestion.length() >= longest.length()) {
                longest = suggestion;
            }
        }
        return longest;
    }

    /**
     * Extracts the word at the current the caretPosition in commandTextField
     */
    private String getWordAtCursor(AutocompleteRequest request) {
        if (request.getPhrase() != null && !request.getPhrase().trim().equals("")) {
            int startIndex = getStartIndexOfWordAtCursor(request);
            int endIndex = getEndIndexOfWordAtCursor(request);
            return request.getPhrase().substring(startIndex, endIndex);
        } else {
            return request.getPhrase();
        }

    }

    /**
     * Gets the start index of the phrase at the caretPosition of the request
     */
    private int getStartIndexOfWordAtCursor(AutocompleteRequest request) {
        if (request.getPhrase().isEmpty()) {
            return 0;
        }

        int currentPosition = request.getCaretPosition();
        int startIndex;
        currentPosition = currentPosition - 1 < 0 ? 0 : currentPosition - 1;
        while (currentPosition > 0  &&
                currentPosition < request.getPhrase().length() &&
                !Character.isWhitespace(request.getPhrase().charAt(currentPosition))) {
            currentPosition--;
        }

        //Increment index by 1 if whitespace is met
        if (Character.isWhitespace(request.getPhrase().charAt(currentPosition))) {
            currentPosition++;
        }

        startIndex = currentPosition;
        return startIndex;
    }

    /**
     * Gets the end index of the phrase at the caretPosition of the request
     */
    private int getEndIndexOfWordAtCursor(AutocompleteRequest request) {
        if (request.getPhrase().isEmpty()) {
            return 0;
        }

        int currentPosition = request.getCaretPosition();
        int endIndex;
        while (currentPosition >= 0  &&
                currentPosition < request.getPhrase().length() &&
                !Character.isWhitespace(request.getPhrase().charAt(currentPosition))) {
            currentPosition++;
        }
        endIndex = currentPosition;
        return endIndex;
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof AutocompleteManager) {
            AutocompleteManager compare = (AutocompleteManager) other;
            AutocompleteRequest request = new AutocompleteRequest("", 0);
            return getSuggestions(request).equals(compare.getSuggestions(request));
        } else {
            return false;
        }
    }

}
```
###### \java\seedu\address\logic\autocomplete\AutocompleteRequest.java
``` java
/**
 * A request class to request for an auto complete at the cursor position
 */
public class AutocompleteRequest {
    protected String phrase;
    protected int caretPosition; //The caret always represents the character on the left of it

    /**
     * Initializes the request with the phrase and the caretPosition
     */
    public AutocompleteRequest(String phrase, int caretPosition) {
        setPhrase(phrase);
        setCaretPosition(caretPosition);
    }

    /**
     * Returns the phrase
     */
    public String getPhrase() {
        return phrase;
    }

    /**
     * Sets the phrase
     */
    public void setPhrase(String phrase) {
        this.phrase = phrase;
    }

    /**
     * Sets the caretPosition
     */
    public int getCaretPosition() {
        return caretPosition;
    }

    /**
     * Sets the caretPosition if valid (between 0 to phrase.length - 1)
     */
    public void setCaretPosition(int caretPosition) {
        assert caretPosition >= 0;
        this.caretPosition = caretPosition;
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof AutocompleteRequest) {
            AutocompleteRequest otherRequest = (AutocompleteRequest) other;
            return (this.caretPosition == otherRequest.caretPosition) &&
                   (this.phrase.equals(otherRequest.phrase));
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\address\logic\autocomplete\AutocompleteResponse.java
``` java
/**
 * A response class that extends request class to contain suggestions and the replaced phrase
 */
public class AutocompleteResponse extends AutocompleteRequest {
    private List<String> suggestions;

    /**
     * Initializes a response with phrase, caretPosition and a list of suggestions
     */
    public AutocompleteResponse(String phrase, int caretPosition, List<String> suggestions) {
        super(phrase, caretPosition);
        setSuggestions(suggestions);
    }

    /**
     * Initializes a response from the {@link AutocompleteRequest}
     */
    public AutocompleteResponse(AutocompleteRequest request, List<String> suggestions) {
        this(request.getPhrase(), request.getCaretPosition(), suggestions);
    }

    /**
     * Returns the suggestions
     */
    public List<String> getSuggestions() {
        return suggestions;
    }

    /**
     * Sets the suggestions list
     */
    public void setSuggestions(List<String> suggestions) {
        this.suggestions = suggestions;
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof AutocompleteResponse) {
            AutocompleteResponse otherResponse = (AutocompleteResponse) other;
            boolean sameCaret = this.caretPosition == otherResponse.caretPosition;
            boolean samePhrase = this.phrase.equals(otherResponse.phrase);
            boolean sameSuggestions = (suggestions == otherResponse.suggestions);
            if (this.suggestions != null && otherResponse.suggestions != null) {
                sameSuggestions = suggestions.containsAll(otherResponse.getSuggestions());
            }
            return sameCaret && samePhrase && sameSuggestions;
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\address\logic\commandhistory\CommandHistory.java
``` java
/**
 * Interface for iterating through the command history
 */
public interface CommandHistory {

    /**
     * Adds a command which has been executed previously
     * @param command - previously executed
     */
    void addCommand(String command);

    /**
     * Returns a previously executed command
     */
    String previous();

    /**
     * Returns the next command (if any) if the user has previously iterated through his commands before
     */
    String next();
}
```
###### \java\seedu\address\logic\commandhistory\CommandHistoryLinkedList.java
``` java
/**
 * Class to keep track of previous command executions
 * Singleton pattern is used as creating multiple instances of CommandHistory would mess up the history of the execution
 */
public class CommandHistoryLinkedList implements CommandHistory {
    private static CommandHistoryLinkedList instance;
    private LinkedList<String> history;
    private ListIterator<String> cursor;
    private boolean hasDirection = false;
    private boolean isTraversingBack = true;

    /**
     * Gets the instance of the CommandHistory
     */
    public static CommandHistoryLinkedList getInstance() {
        if (instance == null) {
            instance = new CommandHistoryLinkedList();
        }
        return instance;
    }

    private CommandHistoryLinkedList() {
        history = new LinkedList<String>();
        resetIterator();
    }

    @Override
    public void addCommand(String command) {
        history.addFirst(command);
        resetIterator();
    }

    @Override
    public String previous() {
        if (cursor.hasNext()) {
            if (hasDirection && !isTraversingBack) {
                cursor.next();
            }

            if (cursor.hasNext()) {
                hasDirection = true;
                isTraversingBack = true;
                return cursor.next();
            }
        }
        return null;
    }

    @Override
    public String next() {
        if (cursor.hasPrevious()) {
            if (hasDirection && isTraversingBack) {
                cursor.previous();
            }
            if (cursor.hasPrevious()) {
                hasDirection = true;
                isTraversingBack = false;
                return cursor.previous();
            } else if (hasDirection && isTraversingBack) {
                //Reset the cursor to where it was before
                cursor.next();
            }
        }
        resetIterator();
        return null;
    }

    /**
     * Brings cursor back to the front
     */
    public void resetIterator() {
        cursor = history.listIterator(0);
        hasDirection = false;
    }
}
```
###### \java\seedu\address\logic\commands\DeleteLabelCommand.java
``` java
/**
 * Edits a label in all tasks that exists in task manager
 */
public class DeleteLabelCommand extends Command {

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Label %1$s deleted from all tasks";
    public static final String MESSAGE_LABEL_NOT_EXIST = "Specified label does not exist in any task saved";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_LABEL_INVALID = "Label name is invalid";

    private Label labelToDelete;

    public DeleteLabelCommand(String labelToDelete) throws IllegalValueException {
        this.labelToDelete = new Label(labelToDelete);
    }

    @Override
    public CommandResult execute() throws CommandException {
        model.updateFilteredListToShowAll();
        List<ReadOnlyTask> allTaskList = model.getFilteredTaskList();
        boolean labelExist = deleteLabelInTasks(allTaskList);

        if (!labelExist) {
            throw new CommandException(MESSAGE_LABEL_NOT_EXIST);
        }

        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, labelToDelete));
    }

    /**
     * Deletes a specific label in all tasks
     * @param allTaskList
     * @return true if the specified label exists
     */
    private boolean deleteLabelInTasks(List<ReadOnlyTask> allTaskList) throws CommandException {
        boolean labelExist = false;
        saveCurrentState();
        for (int i = 0; i < allTaskList.size(); i++) {
            Task task = new Task(allTaskList.get(i));
            UniqueLabelList labels = task.getLabels();
            if (labels.contains(labelToDelete)) {
                Set<Label> labelSet = labels.toSet();
                labelSet.remove(labelToDelete);
                task.setLabels(new UniqueLabelList(labelSet));

                labelExist = true;

                try {
                    model.updateTask(i, task);
                } catch (DuplicateTaskException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_TASK);
                }
            }
        }

        if (!labelExist) {
            deleteCurrentState();
        }

        return labelExist;
    }

    /**
     * Save the data in task manager if command is mutating the data
     */
    public void saveCurrentState() {
        if (isMutating()) {
            try {
                LogicManager.undoCommandHistory.addStorageHistory(model.getTaskManager().getImmutableTaskList(),
                        model.getTaskManager().getImmutableLabelList());
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Deletes the data in task manager if command is mutating the data
     */
    public void deleteCurrentState() {
        UndoManager.getInstance().getUndoData();
    }

    @Override
    public boolean isMutating() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\EditLabelCommand.java
``` java
/**
 * Edits a label in all tasks that exists in Task Manager
 */
public class EditLabelCommand extends Command {

    public static final String COMMAND_WORD = "editlabel";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits a label to another label \n"
            + "Existing label will be overwritten by the new label.\n"
            + "Parameters: LABEL_TO_EDIT NEW_LABEL \n"
            + "Example: " + COMMAND_WORD + " school schoolwork";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Labels changed from %1$s to %2$s";
    public static final String MESSAGE_LABEL_NOT_EXIST = "Specified label does not exist in any task saved";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_LABEL_INVALID = "Label name is invalid";

    private Label labelToChange;
    private Label newLabel;

    public EditLabelCommand(String labelToChange, String newLabel) throws IllegalValueException {
        this.labelToChange = new Label(labelToChange);
        this.newLabel = new Label(newLabel);
    }

    @Override
    public CommandResult execute() throws CommandException {
        model.updateFilteredListToShowAll();
        List<ReadOnlyTask> allTaskList = model.getFilteredTaskList();
        boolean labelExist = replaceLabelInTasks(allTaskList);

        if (!labelExist) {
            throw new CommandException(MESSAGE_LABEL_NOT_EXIST);
        }

        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, labelToChange, newLabel));
    }

    /**
     * Replaces a specific label in all tasks
     * @param allTaskList
     * @return true if the specified label exists
     */
    private boolean replaceLabelInTasks(List<ReadOnlyTask> allTaskList) throws CommandException {
        boolean labelExist = false;
        for (int i = 0; i < allTaskList.size(); i++) {
            Task task = new Task(allTaskList.get(i));
            UniqueLabelList labels = task.getLabels();
            if (labels.contains(labelToChange)) {
                Set<Label> labelSet = labels.toSet();
                labelSet.remove(labelToChange);
                labelSet.add(newLabel);
                task.setLabels(new UniqueLabelList(labelSet));

                labelExist = true;

                try {
                    saveCurrentState();
                    model.updateTask(i, task);
                } catch (DuplicateTaskException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_TASK);
                }
            }
        }
        return labelExist;
    }

    /**
     * Save the data in task manager if command is mutating the data
     */
    public void saveCurrentState() {
        if (isMutating()) {
            try {
                LogicManager.undoCommandHistory.addStorageHistory(model.getTaskManager().getImmutableTaskList(),
                        model.getTaskManager().getImmutableLabelList());
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public boolean isMutating() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\LoadCommand.java
``` java
/**
* Loads the Task Manager data from a specific path
*/
public class LoadCommand extends Command {
    public static final String COMMAND_WORD = "load";

    public static final String MESSAGE_USAGE = COMMAND_WORD +
            ": Loads data from a new file relative to DoOrDie Task Manager " +
            "Parameters: FILE_PATH_RELATIVE_TO_JAR_FILE\n" +
            "Example: " + COMMAND_WORD + " data/taskmanager.xml";

    public static final String MESSAGE_SUCCESS = "Loaded data from %1$s, now using %1$s as storage file";
    public static final String MESSAGE_DOES_NOT_END_WITH_XML = "File must end in .xml";
    public static final String MESSAGE_FILE_DOES_NOT_EXIST = "File does not exist";

    private String storagePath;

    public LoadCommand(String storagePath) {
        this.storagePath = storagePath.trim();
    }

    @Override
    public CommandResult execute() throws CommandException {
        File file = new File(storagePath);
        if (!FileUtil.isFileExists(file)) {
            return new CommandResult(MESSAGE_FILE_DOES_NOT_EXIST);
        } else if (storagePath.endsWith(".xml")) {
            EventsCenter.getInstance().post(new FileStorageChangedEvent(storagePath));
            return new CommandResult(String.format(MESSAGE_SUCCESS, storagePath));
        } else {
            return new CommandResult(MESSAGE_DOES_NOT_END_WITH_XML);
        }
    }

    @Override
    public boolean isMutating() {
        return false;
    }
}
```
###### \java\seedu\address\logic\commands\SaveAsCommand.java
``` java
/**
 * Saves the Task Manager data to a specific path
 */
public class SaveAsCommand extends Command {
    public static final String COMMAND_WORD = "saveas";

    public static final String MESSAGE_USAGE = COMMAND_WORD +
            ": Save data to a new filepath relative to DoOrDie Task Manager" +
            "Parameters: FILE_PATH_RELATIVE_TO_JAR_FILE\n" +
            "Example: " + COMMAND_WORD + " data/taskmanager2.xml";

    public static final String MESSAGE_SUCCESS = "Saved to path : %1$s";
    public static final String MESSAGE_DOES_NOT_END_WITH_XML = "File must end in .xml";

    private String storagePath;

    public SaveAsCommand(String storagePath) {
        this.storagePath = storagePath.trim();
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (storagePath.endsWith(".xml")) {
            EventsCenter.getInstance().post(new ForceSaveEvent(storagePath));
            EventsCenter.getInstance().post(new FileStorageChangedEvent(storagePath));
            return new CommandResult(String.format(MESSAGE_SUCCESS, storagePath));
        } else {
            return new CommandResult(MESSAGE_DOES_NOT_END_WITH_XML);
        }
    }

    @Override
    public boolean isMutating() {
        return false;
    }
}
```
###### \java\seedu\address\logic\parser\DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    private static final String DELIMITER = " ";
    private static final int ARGUMENT_LABEL_TO_DELETE_INDEX = 0;
    private static final int ARGUMENT_LENGTH = 1;
    private static final String REGEX_INDEX = "^[0-9\\+\\-][0-9]*$";

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteCommand
     * and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);

        try {
            String[] arguments = argsTokenizer.getPreamble().get().split(DELIMITER);
            if (arguments.length != ARGUMENT_LENGTH) {
                throw new CommandException(DeleteCommand.MESSAGE_USAGE);
            }

            String parameter = arguments[ARGUMENT_LABEL_TO_DELETE_INDEX];
            if (parameter.matches(REGEX_INDEX)) { //matches 0-9 or + or - for the first character
                return tryParseAsIndex(args);
            } else {
                return new DeleteLabelCommand(arguments[ARGUMENT_LABEL_TO_DELETE_INDEX]);
            }
        } catch (Exception e) { }
        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
    }

    /**
     * Try parsing arguments as index
     */
    private Command tryParseAsIndex(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (index.isPresent()) {
            return new DeleteCommand(index.get());
        } else {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\seedu\address\logic\parser\EditLabelCommandParser.java
``` java
/**
* Parses input arguments and creates a new EditLabelCommand object
*/
public class EditLabelCommandParser {

    private static final String DELIMITER = " ";
    private static final int ARGUMENT_NEW_LABEL_INDEX = 1;
    private static final int ARGUMENT_LABEL_TO_CHANGE_INDEX = 0;
    private static final int ARGUMENT_LENGTH = 2;

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditLabelCommand and returns an EditLabelCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);

        try {
            String[] arguments = argsTokenizer.getPreamble().get().split(DELIMITER);
            if (arguments.length != ARGUMENT_LENGTH) {
                throw new CommandException(EditLabelCommand.MESSAGE_USAGE);
            }

            return new EditLabelCommand(arguments[ARGUMENT_LABEL_TO_CHANGE_INDEX], arguments[ARGUMENT_NEW_LABEL_INDEX]);
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(EditLabelCommand.MESSAGE_LABEL_INVALID));
        } catch (Exception e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditLabelCommand.MESSAGE_USAGE));
        }
    }
}
```
###### \java\seedu\address\MainApp.java
``` java
    /**
     * Load all fonts in the resources/fonts folder
     */
    private void loadFonts() {
        Font.loadFont(getClass().getResourceAsStream("/fonts/YouMurdererBB-Regular.otf"), 10);
        Font.loadFont(getClass().getResourceAsStream("/fonts/Roboto-Condensed.ttf"), 10);
        Font.loadFont(getClass().getResourceAsStream("/fonts/Roboto-Regular.ttf"), 10);
        Font.loadFont(getClass().getResourceAsStream("/fonts/FontAwesome-Regular.otf"), 10);
    }
```
###### \java\seedu\address\MainApp.java
``` java
    /**
     * Handles FileStorageChangedEvent to load the data from the new location
     * @throws Exception
     */
    @Subscribe
    public void handleFileStorageChangedEvent(FileStorageChangedEvent event) throws Exception {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        //Update & save the config file
        config.setTaskManagerFilePath(event.getFilePath());
        try {
            ConfigUtil.saveConfig(config, configPath);
        } catch (IOException e) {
            e.printStackTrace();
        }

        //Reinitialize components
        storage.setTaskManagerFilePath(event.getFilePath());
        model = initModelManager(storage, userPrefs);
        logic = new LogicManager(model, storage);
        //Set the Ui to the new logic since we don't want to destroy the old UI
        ui.setLogic(logic);
        //Update UI to show all tasks since we have loaded the new Task Manager in
        model.updateFilteredListToShowAll();

        //Restart the undo manager
        UndoManager.getInstance().clear();

        //Save all current data into the new location
        storage.saveTaskManager(model.getTaskManager(), event.getFilePath());
    }

    /**
     * Handles ForceSaveEvent to save the config to a location
     * @throws Exception
     */
    @Subscribe
    public void handleForceSaveEvent(ForceSaveEvent event) throws Exception {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        storage.saveTaskManager(model.getTaskManager(), event.getFilePath());
    }
```
###### \java\seedu\address\model\datastructure\Trie.java
``` java
/**
 * Data structure used to store auto complete data
 */
public class Trie implements AutocompleteDataStructure {
    private TrieNode rootNode;

    /**
     * Initializes a new Trie data structure with an empty root node
     */
    public Trie() {
        super();
        rootNode = new TrieNode(' ');
    }

    /**
     * Loads phrases used for auto completion into the Trie
     * @param phrases
     */
    @Override
    public void load(String... phrases) {
        for (String phrase : phrases) {
            loadRecursive(rootNode, phrase + "$");
        }
    }

    /**
     * Loads phrases character by character into the Trie
     * @param node - root to add the phrase from
     * @param phrase - phrase to add
     */
    private void loadRecursive(TrieNode node, String phrase) {
        if (StringUtils.isBlank(phrase)) {
            return;
        }
        char firstChar = phrase.charAt(0);
        node.add(firstChar);
        TrieNode childNode = node.getChildNode(firstChar);
        if (childNode != null) {
            loadRecursive(childNode, phrase.substring(1));
        }
    }

    /**
     * Checks recursively if each node contains a specific prefix
     * @param node - The node to check
     * @param prefix - the string to match
     * @return true if the node or any of its children contains the prefix
     */
    private TrieNode matchPrefixRecursive(TrieNode node, String prefix) {
        if (StringUtils.isBlank(prefix)) {
            return node;
        }
        char firstChar = prefix.charAt(0);
        TrieNode childNode = node.getChildNode(firstChar);
        if (childNode == null) {
            // no match at this char, exit
            return null;
        } else {
            // go deeper
            return matchPrefixRecursive(childNode, prefix.substring(1));
        }
    }

    /**
     * Finds a list of completions that can be made using the current prefix
     * @param prefix - to match against
     * @return a list of strings with auto completed suggestions
     */
    @Override
    public List<String> findCompletions(String prefix) {
        TrieNode matchedNode = matchPrefixRecursive(rootNode, prefix);
        List<String> completions = new LinkedList<String>();
        findCompletionsRecursive(matchedNode, prefix, completions);
        return completions;
    }

    /**
     * Finds a list of completions that can be made using the current prefix recursively
     * @param node - current node to check
     * @param prefix - to match against
     * @param completions - List of completions that are currently matched
     */
    private void findCompletionsRecursive(TrieNode node, String prefix, List<String> completions) {
        if (node == null) {
            // our prefix did not match anything, just return
            return;
        }
        if (node.getNodeValue() == '$') {
            /*
             * end reached, append prefix into completions list. Do not append
             * the trailing $, that is only to distinguish words like ann and
             * anne into separate branches of the tree.
             */
            completions.add(prefix.substring(0, prefix.length() - 1));
            return;
        }
        Collection<TrieNode> childNodes = node.getChildren();
        for (TrieNode childNode : childNodes) {
            char childChar = childNode.getNodeValue();
            findCompletionsRecursive(childNode, prefix + childChar, completions);
        }
    }
}
```
###### \java\seedu\address\model\datastructure\TrieNode.java
``` java
/**
 * Nodes that are contained in data structure {@link Trie}
 */
public class TrieNode {

    private Character character;
    private HashMap<Character, TrieNode> children;

    public TrieNode(char c) {
        super();
        this.character = new Character(c);
        children = new HashMap<Character, TrieNode>();
    }

    /**
     * Gets the value of the node
     */
    public char getNodeValue() {
        return character.charValue();
    }

    /**
     * Get the children of the current node
     */
    public Collection<TrieNode> getChildren() {
        return children.values();
    }

    /**
     * Gets the values of the children of the current node
     */
    public Set<Character> getChildrenNodeValues() {
        return children.keySet();
    }

    /**
     * Adds a child to the current node
     */
    public void add(char c) {
        if (children.get(new Character(c)) == null) {
            // children does not contain c, add a TrieNode
            children.put(new Character(c), new TrieNode(c));
        }
    }

    /**
     * Gets a child node
     * @param c - the key whose associated value is to be returned
     * @return - the value to which the specified key is mapped, or null if this map contains no mapping for the key
     */
    public TrieNode getChildNode(char c) {
        return children.get(new Character(c));
    }

    /**
     * Checks if the child has such a character
     * @param c - the key whose associated value is to be returned
     * @return - true if there is a match
     */
    public boolean contains(char c) {
        return (children.get(new Character(c)) != null);
    }

    @Override
    public int hashCode() {
        return character.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof TrieNode)) {
            return false;
        }
        TrieNode that = (TrieNode) obj;
        return (this.getNodeValue() == that.getNodeValue());
    }
}
```
###### \java\seedu\address\model\label\Label.java
``` java
/**
 * Represents a Label in DoOrDie Task Manager Application
 * Guarantees: immutable; name is valid as declared in {@link #isValidLabelName(String)}
 */
public class Label {

    public static final String MESSAGE_LABEL_CONSTRAINTS =
            "Label names should be alphanumeric, first character of label should be alphabetical";
    public static final String LABEL_VALIDATION_REGEX = "^[a-zA-Z][a-zA-Z0-9]+$";

    public final String labelName;

    /**
     * Validates given label name.
     *
     * @throws IllegalValueException if the given label name string is invalid.
     */
    public Label(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidLabelName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_LABEL_CONSTRAINTS);
        }
        this.labelName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid label name.
     */
    public static boolean isValidLabelName(String test) {
        return test.matches(LABEL_VALIDATION_REGEX);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Label // instanceof handles nulls
                        && this.labelName.equals(((Label) other).labelName)); // state check
    }

    @Override
    public int hashCode() {
        return labelName.hashCode();
    }

    /**
     * Returns labelName in String
     */
    public String getLabelName() {
        return labelName;
    }

    /**
     * Format state as text for viewing.
     */
    public String toString() {
        return '[' + labelName + ']';
    }

}
```
###### \java\seedu\address\model\label\UniqueLabelList.java
``` java
/**
 * A list of labels that enforces no nulls and uniqueness between its elements.
 *
 * Supports minimal set of list operations for the app's features.
 *
 * @see Label#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueLabelList implements Iterable<Label> {

    private final ObservableList<Label> internalList = FXCollections.observableArrayList();

    /**
     * Constructs empty LabelList.
     */
    public UniqueLabelList() {}

    /**
     * Creates a UniqueLabelList using given String labels. Enforces no nulls or
     * duplicates.
     */
    public UniqueLabelList(String... labels) throws DuplicateLabelException, IllegalValueException {
        final List<Label> labelList = new ArrayList<Label>();
        for (String label : labels) {
            labelList.add(new Label(label));
        }
        setLabels(labelList);
    }

    /**
     * Creates a UniqueLabelList using given labels. Enforces no nulls or
     * duplicates.
     */
    public UniqueLabelList(Label... labels) throws DuplicateLabelException {
        assert !CollectionUtil.isAnyNull((Object[]) labels);
        final List<Label> initialLabels = Arrays.asList(labels);
        if (!CollectionUtil.elementsAreUnique(initialLabels)) {
            throw new DuplicateLabelException();
        }
        internalList.addAll(initialLabels);
    }

    /**
     * Creates a UniqueLabelList using given labels. Enforces no null or
     * duplicate elements.
     */
    public UniqueLabelList(Collection<Label> labels) throws DuplicateLabelException {
        this();
        setLabels(labels);
    }

    /**
     * Creates a UniqueLabelList using given labels. Enforces no nulls.
     */
    public UniqueLabelList(Set<Label> labels) {
        assert !CollectionUtil.isAnyNull(labels);
        internalList.addAll(labels);
    }

    /**
     * Creates a copy of the given list. Insulates from changes in source.
     */
    public UniqueLabelList(UniqueLabelList source) {
        internalList.addAll(source.internalList); // insulate internal list from
                                                  // changes in argument
    }

    /**
     * Returns all labels in this list as a Set. This set is mutable and
     * change-insulated against the internal list.
     */
    public Set<Label> toSet() {
        return new HashSet<>(internalList);
    }

    /**
     * Replaces the Tags in this list with those in the argument label list.
     */
    public void setLabels(UniqueLabelList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setLabels(Collection<Label> labels) throws DuplicateLabelException {
        assert !CollectionUtil.isAnyNull(labels);
        if (!CollectionUtil.elementsAreUnique(labels)) {
            throw new DuplicateLabelException();
        }
        internalList.setAll(labels);
    }

    /**
     * Removes all labels from the list. Warning, this cannot be undone!
     */
    public void removeAll() {
        internalList.clear();
    }

    @Override
    public UniqueLabelList clone() {
        UniqueLabelList labelList = new UniqueLabelList();
        try {

            for (Label label : internalList) {
                labelList.add(new Label(label.getLabelName()));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return labelList;
    }

    /**
     * Ensures every label in the argument list exists in this object.
     */
    public void mergeFrom(UniqueLabelList from) {
        final Set<Label> alreadyInside = this.toSet();
        from.internalList.stream().filter(label -> !alreadyInside.contains(label)).forEach(internalList::add);
    }

    /**
     * Returns true if the list contains an equivalent Label as the given
     * argument.
     */
    public boolean contains(Label toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Returns true if the list contains an equivalent Label as the given
     * argument.
     */
    public boolean containsStringLabel(String labelToCheck) {
        assert labelToCheck != null;
        // return internalList.contains(toCheck);
        for (Label label : internalList) {
            if (label.getLabelName().equalsIgnoreCase(labelToCheck)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Adds a Label to the list.
     *
     * @throws DuplicateLabelException
     *             if the Label to add is a duplicate of an existing Label in
     *             the list.
     */
    public void add(Label toAdd) throws DuplicateLabelException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateLabelException();
        }
        internalList.add(toAdd);
    }

    @Override
    public Iterator<Label> iterator() {
        return internalList.iterator();
    }

    public UnmodifiableObservableList<Label> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueLabelList // instanceof handles nulls
                        && this.internalList.equals(((UniqueLabelList) other).internalList));
    }

    public boolean equalsOrderInsensitive(UniqueLabelList other) {
        return this == other || new HashSet<>(this.internalList).equals(new HashSet<>(other.internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates'
     * property of the list.
     */
    public static class DuplicateLabelException extends DuplicateDataException {
        protected DuplicateLabelException() {
            super("Operation would result in duplicate labels");
        }
    }

}
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    /**
     * Hijacks the tab character for auto-completion, up/down for iterating through the command
     */
    @FXML
    private void handleOnKeyPressed(KeyEvent ke) {
        if (ke.getCode() == KeyCode.TAB) {
            //Extract the command as well as the caret position
            String command = commandTextField.getText();
            int caretPosition = commandTextField.getCaretPosition();

            //Create a auto complete request
            AutocompleteRequest request = new AutocompleteRequest(command, caretPosition);
            //Get the response using the auto complete manager
            AutocompleteResponse response = autocompleteManager.getSuggestions(request);

            //Update fields with the response
            updateAutocompleteFeedback(response);
            commandTextField.setText(response.getPhrase());
            commandTextField.positionCaret(response.getCaretPosition());

            //Consume the event so the text field will not go to the next ui component
            ke.consume();
        } else if (ke.getCode() == KeyCode.UP) {
            getPreviousCommand();
            ke.consume();
        } else if (ke.getCode() == KeyCode.DOWN) {
            getNextCommand();
            ke.consume();
        }
    }

    /**
     * Gets the next executed command from the current command (if iterated through before)
     */
    private void getNextCommand() {
        String command = commandHistory.next();
        setCommandAndCursorToEnd(command);
    }

    /**
     * Gets the previously executed command from the current command
     */
    private void getPreviousCommand() {
        String command = commandHistory.previous();
        setCommandAndCursorToEnd(command);
    }

    /**
     * Sets the command to the string input given along with the cursor at the end
     */
    private void setCommandAndCursorToEnd(String command) {
        command = command == null ? commandTextField.getText() : command;
        commandTextField.setText(command);
        moveCursorToEndOfField();
    }

    /**
     * Moves the cursor in commandTextField to the end of the string
     */
    private void moveCursorToEndOfField() {
        commandTextField.positionCaret(commandTextField.getLength());
    }

    /**
     * Updates the output window to either nothing or a list of suggestions
     */
    private void updateAutocompleteFeedback(AutocompleteResponse response) {
        if (response.getSuggestions().size() > 1) { //Show list of suggestions if more than 1
            raise(new NewResultAvailableEvent(response.getSuggestions().toString()));
        } else {
            raise(new NewResultAvailableEvent(""));
        }
    }

    /**
     * Sets the command box style to indicate a successful command.
     */
    private void setStyleToIndicateCommandSuccess() {
        commandTextField.getStyleClass().remove(ERROR_STYLE_CLASS);
    }

    /**
     * Sets the command box style to indicate a failed command.
     */
    private void setStyleToIndicateCommandFailure() {
        commandTextField.getStyleClass().add(ERROR_STYLE_CLASS);
    }

    public void setLogic(Logic logic) {
        this.logic = logic;
    }
}
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    /**
     * Fill up components in the main window,
     * but only update appropriate components if already initialized
     */
    public void fillInnerParts() {
        //browserPanel = new BrowserPanel(browserPlaceholder);

        if (taskListPanel == null) {
            taskListPanel = new TaskListPanel(getTaskListPlaceholder(), logic.getFilteredTaskList());
        } else {
            //Update the logic only
            taskListPanel.setConnections(logic.getFilteredTaskList());
        }

        if (leftPanel == null) {
            leftPanel = new LeftPanel(getleftPanelPlaceholder(),
                                logic.getFilteredTaskList(),
                                model.getTaskManager().getLabelList());
        } else {
            leftPanel.setConnections(model.getTaskManager().getLabelList());
        }

        if (resultDisplay == null) {
            resultDisplay = new ResultDisplay(getResultDisplayPlaceholder());
        }

        if (statusBarFooter == null) {
            statusBarFooter = new StatusBarFooter(getStatusbarPlaceholder(), config.getTaskManagerFilePath());
        } else {
            statusBarFooter.setSaveLocation(config.getTaskManagerFilePath());
        }

        if (commandBox == null) {
            commandBox = new CommandBox(getCommandBoxPlaceholder(), logic);
        } else {
            commandBox.setLogic(logic);
        }
    }
```
